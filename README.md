# about_Java
Java를 공부하며 알게 된 것을 기록하는 저장소입니다.

# 관련 링크
- https://velog.io/@superscman/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84-4%ED%83%84


# 디자인 패턴의 분류 
## 생성 패턴
- 기존 코드의 재활용과 유연성을 증가시키는 객체 생성 메커니즘들을 제공.
```
팩토리 메서드
추상 팩토리
빌더
프로토타입
싱글턴
```
## 구조 패턴
- 구조를 유연하고 효율적으로 유지하면서 객체와 클래스를 더 큰 구조로 조합하는 방법을 설명.
```
어댑터
브리지
복합체
데코레이터
퍼사드
플라이웨이트
프록시
```

## 행동 패턴
- 행동 패턴은 객체 간의 효과적인 의사소통과 책임 할당을 처리.
```
책임연쇄
커맨드
반복자
중재자
메멘토
옵서버
상태
전략
탬플릿 메서드
비지터
```

# 팩토리 메서드 
- 부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만
- **자식 클래스들이 생성될 객체들의 유형을 변경**할 수 있도록 생성하는 생성 패턴.
- 팩토리 메서드 패턴은 (new 연산자를 사용한) 객체 생성 직업 호출들을 특별한 팩토리 메서드에 대한 호출들도 대체하라고 제안.
- 객체들은 new 연산자를 통해 생성되지만 팩토리 메서드 내에서 호출됨.
- 자식 클래스에서 팩토리 메서드를 오버라이딩하고 그 메서드에 의해 생성되는 제품들의 클래스를 변경할 수 있음
- 제한사항) 자식 클래스들은 다른 유형의 제품들과의 공통 기초 클래스 또는 공통 인터페이스가 있는 경우에만 반환 가능. 

## 적용 상황
- 코드가 함께 작동해야하는 객체들의 정확한 유형들과 의존관계들을 미리 모르는 경우
- 라이브러리 또는 프레임워크의 사용자들에게 내부 컴포넌트들을 확장하는 방법 제공하고 싶을 때
- 팩토리 메서드는 기존 객체들을 매번 재구축하는 대신 이들을 재사용하여 시스템 리소스를 절약하고 싶을 때

# 추상 팩토리
- 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴
- 관련 객체들의 구상 클래스들을 지정하지 않고도 그들의 패밀리를 생성할 수 있도록 하는 생성 패턴.
- 추상 팩토리 패턴의 첫 번쨰 방안은 각 제품 패밀리(제품군)에 해당하는 개별젹인 인터페이스를 명시적으로 선언. 
- 그 다음 추상 팩토리 선언. 제품 패밀리내의 모든 개별 제품들의 생성 메서드들이 목록화 되어 있는 인터페이스

# 빌더
- 복잡한 객체들을 단계별로 생성할 수 있도록 생성 디자인 패턴
- 같은 생성 코드를 사용하여 객체의 다양한 유형들과 표현을 생성 가능.
- 빌더는 제품이 생성되는 동안 다른 객체들이 제품에 접근 하는 것을 허용하지 않음. 
- 더 나아가 제품을 생성하는데 사용하는 빌더 단계들에 대한 일련의 호출을 디렉터(관리자)라는 별도의 클래스로 추출 가능.
- 디렉터 클래스는 건축 단계들을 실행하는 순서를 정의하는 반면 빌더는 이러한 단계들에 대한 구현을 제공합니다. 

# 프로토타입
- 프로토타입은 코드를 그들의 클래스에 의존시키지 않고 기존 객체들을 복사할 수 있도록 하는 생성 디자인 패턴.

# 싱긅턴
- 클래스에 인스턴스가 하나만 있도록 하면서 이 인스턴스에 대한 전역 접근 지점을 제공하는 생성 디자인 패턴
- 애플리케이션이 시작될 때 어떤 클래스가 최초 한 번만 메모리를 실행하고 (static) 그 메모리에 인스턴스를 만들어서 사용하는 패턴.
- 생성자가 여러 차례 호출 되더라도 실체로 생성되는 객체는 하나이고, 최초 생성 후 호출된 생성자는 최소 생성 객체를 반환. 
- 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와, 동일한 인스턴스를 자주 생성해야하는 경우에 사용.(메모리 낭비 방지)
- 예시로 스프링 빈(Spring Bean) : 스프링은 요청할 때마다 새로운 객체를 생성해서 반환하는 기능도 제공.




# 네트워크

# 쿠키 vs 세션
## 쿠키와 세션을 사용하는 이유
- HTTP 프로토콜 환경은 connectionless, stateless한 특성을 갖기 때문에 서버는 클라이언트가 누구인지 매번 확인해야함.
- 이 특성을 보완하기 위해서 쿠키와 세션을 사용함.
- cf) connectionless : 클라이언트가 요청을 한 후 응답받으면 연결을 끊어버리는 특징. 
- cf) stateless : 통신이 끝나면 상태를 유지하지 않는 특징. 
## 쿠키
### 쿠키 개념
- 쿠키는 클라이언트 로컬에 저장되는 키와 값이 들어있는 데이터 파일
- 사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징.
- 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조.
- 클라이언트에 300개까지 쿠키 저장 간으, 하나의 도메인당 20개의 값만 가짐. 하나의 쿠키값은 4KB까지 저장.
- Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있음.
- 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request 시에 Request Header를 넣어서 자동으로 서버에 전송.
### 쿠키 구성 요소
- 이름 : 각각 쿠키를 구별하는데 사용되는 이름
- 값 : 쿠키의 이름과 관련된 값
- 유효시간 : 쿠키의 유지시간
- 도메인 : 쿠키를 전송할 도메인
- 경로 : 쿠키를 전송할 요청 경로
### 쿠키의 동작 방식
- 클라이언트가 페이지를 요청
- 서버에서 쿠리를 생성
- HTTP 헤더에 쿠키를 포함시켜서 응답
- 브라우저가 종료되어도 쿠키 만료기간이 있다면 클라이언트에서 보관하고 있음.
- 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함꼐 보냄
- 서버에서 쿠키를 읽어 이전 상태 정보를 변경할 필요가 있을 때 쿠키를 업데이트하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답. 

## 세션
### 세션 개념
- **세션은 쿠키를 기반**으로 하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버측에서 관리. 
- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하여 웹 브라우저가 서버에 접속해서 브라우저를 종료할 떄까지 인증 상태를 유지. 
- 접속 시간에 제한을 두어 일정시간 응답이 없다면 정보가 유지되지 않게 설정 가능.
- 사용자에 대한 정보를 서버에 두기 때문에, 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지 하게 됌.
- 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여, 이것이 세션 ID. 
### 세션 동작 방식
- 클라이언트가 서버에 접속 시 세션 ID를 발급 받음.
- 클라이언트는 세션 ID에 대해 **쿠키를 사용해서 저장하고 가지고 있음**.
- 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청.
- 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라이언트 정보 가져와서 사용
- 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답.

### 세션의 특징
- 각 클라이언트에게 고유 ID 부여
- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 보안면에서 쿠키보다 우수
- 사용자가 많아질수록 서버 메모리를 많이 차지하게 됌.

### 세션의 사용 예
- 로그인 같이 보안상 중요한 작업을 수행할 때 사용. 

## UDP VS TCP
- UDP : 비연결형 - DNS -> 어떤 호스트 네임의 IP주소를 찾을 필요가 있는 프로그램은 DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보냄.
- TCP : 연결지향형

# HTTP
- 3 웨이 핸드셰이크
## HTTP 구조
- https://programmer93.tistory.com/60
## HTTP/2
- 멀티 플렉싱 : 여개의 스트림을 사용하여 송수신. 단일 연결 사용하여 병렬로 요청
## HTTPS
- 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 HTTP.
### 인증 메커니즘
- CA에서 발급한 인증서를 기반. 연결을 시작하는데 있어 필요한 공개키를 클라이언트에 제공하고, 사용자가 접속한 '서버가 신뢰'할 수 있는 서버임을 보장함. 
- CA에서 인증서를 발급 받으려면 자신의 사이트 정보와 공개키를 CA에 제출. CA는 공개키를 해시한 값인 지문을 사용하는 CA 비밀키 등을 기반으로 인증서 발급. 

#### SEO(서치엔진 최적화)에 도움이 된 HTTPS
- 참고. HTTPS, 캐노니컬 설정, 메타 설정, 페이지 속도 개선, 사이트맵 관리 등을 통해 SEO 관리.

## HTTP1 vs HTTP2
- 장점 두가지 멀티 플렉싱 서버 푸시 
- 멀티 플렉싱 : 여러 스트림을 사용하여 송수신하여 특정 스트림의 패킷이 손실되었더라도 해당 스트림에만 영향
- 서버 푸시란 클라이언트 요청 없이 서버가 바로 리소스 푸시. 

## GET vs POST
- GET : header 부분에 담김 노출됨. 캐시 가능. 
- POST : boby 부분에 담겨서 데이터의 크기가 크고(바이너리 가능) 보안면에서 낫다. 요청헤더의 content-type에 요청 데이터의 타입을 표시해야함.


# DB

## DB 인덱싱
- 인덱스 보통 B-트리 자료구조로 이루어짐. 
- 인덱스에 의해 데이터들이 정렬된 형태를 갖게 되어 빠른 서치 가능. 
- Mysql에서 클러스터형 인덱스, 세컨더리 인덱스. 
- 클러스터형 인덱스는 테이블 당 하나 설정 -> primary key옵션으로 기본키 만들거나 unique not null
- 세컨터리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성하는 인덱스. 
### 인덱스 사용 하면 좋은 경우
- 규모가 큰 테이블
- 삽입, 수정, 삭제가 자주 발생하지 않는 칼럼
- where나 order by, join 자주 사용되는 칼럼
- 데이터의 중복도가 낮은 칼럼

## ORM vs SQL Mapper VS JDBC
- 퍼시스턴스 : 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성 (영속성)
### sql mapper
- 퍼시스턴스 프레임워크 중 하나로, sql을 직접 작성. sql문과 객체의 필드를 매핑하여 데이터를 객체화. 
- MyBatis : 반복적인 jdbc 프로그래밍을 단순화. sql쿼리들을 xml파일에 작성하여 코드와 sql을 분리. 
- -> jdbc만 사용하면 결과를 가져와서 객체의 인스턴스에 매핑하기 위한 많은 코드가 필요하겠지만, 마이바티스는 그 코드를 작성하지 않아도 되게 해준다. 
- 마이바티스 단점 : db에 종석적, 간단한 crud도 반복적으로 작성, 테이블 필드 변경 시,관련된 sql문, 객체 필드 등 수동 수정. 
- 코드상으로는 sql과 jdbc 분리 되었지만 논리적으로는 강한 의존성을 갖고 있음. 

### JPA
- db와 객체지향 의 패러다임 불일치를 해소
- 상속, 연관관계 매핑->관계설정하여 내부적으로 해결.

# JAVA

## JVM의 역할
- JVM은 스택 기반으로 동작, Java Byte Code를 OS에 맞게 해석해주는 역할. 가바지 컬렉션을 통해 자동적인 메모리 관리해줌.

## Java의 컴파일 과정
- 개발자가 .java 파일 생성 
- build
- java complier의 javac의 명령어를 통해 바이트 코드(.class)를 생성.
- Class Loader를 통해 JVM 메모리 내로 로드.
## Java 타입, 바이트 크기
- byte -> 1바이트
- short -> 2바이트
- int -> 4바이트
- long -> 8바이트
- float -> 4바이트
- double -> 8바이트
- char -> 2바이트
- boolean -> 1바이트

## 불변 객체
- 불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체
- Java에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만듬.
### 불변객체 - 참조타입
- 참조 변수가 일반 객체일 경우 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경.
- 배열일 경우 배열을 받아 copy 저장, getter를 clone으로 반환... (배열을 그대로 참조하거나 반환할경우, 외부에서 내부 값 변경 가능.)
- 리스트인 경우에도 배열과 마찬가지로 생성시 새로운 List를 만들어 값을 복사. 
### 불변 객체나 final 굳이 사용해야할 이유
- 스레드에 안전
- 예외 발생하더라도 전과 같은 상태로 처리 가능
- 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장
- 가비지 컬렉션 성능 높임.

## 추상클래스와 인터페이스 차이.
- 추상 클래스 : 클래스 내 추상 메소드가 하나 이상 포함이거나 abstract로 정의된 경우,
- 인터페이스 :  모든 메소드가 추상 메소드로만 이루어져 있는 경우. 
### 공통점
- new 연산자로 인스턴스 생성 불가능
- 사용하기 위해서는 하위 클래스에서 확장/구현 해야함.
### 차이점
- 인터페이스 : 구현하는 모든 클래스에 대해 특정 메소드가 반드시 존재함을 강제함.
- 추상 클래스 : 상속 받는 클래스들의 공통 로직을 추상화, 기능 확장.
- 추상 클래스 다중상속 불가, 인터페이스 다중상속 가능.

## 가비지 컬렉션
- JVM 메모리 관리 기법 중 하나로 시스템에서 동적을 할당 됐던 메모리 영역 중에서 필요 없어진 메모리 영역을 회수하여 메모리를 관리.
- GC의 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고, GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후, 사용하지 않는 메모리를 제거하고 작업이 제개됨. 
- JVM 의 Garbage Collector 는 **Unreachable Object** 를 우선적으로 메모리에서 제거하여 메모리 공간을 확보한다. Unreachable Object 란 Stack 에서 도달할 수 없는 Heap 영역의 객체를 말함.

## 에러와 예외 차이
- 에러 : 메모리 부족, 스택 오버 플로우와 같이 발생하게 되면 복구할 수 없는 심각한 오류
- 예외 : 발생하더라도 수습할 수 있을 정도의 비교적 덜 심각한 오류 -> 예외처리를 통해서 비정상 종료를 막을 수 있음.
### CheckedException과 UnCheckedException의 차이
- CheckedException은 실행하기 전에 예측 가능한 예외. 반드시 예외처리를 해야함.
- ex) IOException, ClassNotFoundException 등.
- UncheckException은 실행하고 난 후에 알 수 있는 예외. 따로 예외처리하지 않음.
- ex) NullPointerException, ArrayIndexOutOfBoundException 등.

## 객체지향 설계원칙
- SRP(단일 책임 원칙) : 한 클래스는 하나의 책임만 가진다.
- OCP(개방 폐쇄 원칙) : 확장에는 열려 있고, 수정에는 닫혀 있다.
- LSP(리스코프 치환 원칙) : 상위 타입은 항상 하위 타입으로 대체할 수 있어야 한다.
- ISP(인터페이스 분리 원칙) : 인터페이스 내에 메소드는 최소한 일수록 좋다.(하나의 일반 인터페이스보다 여러 개의 구체적 인터페이스가 낫다.) - SRP와 같은 문제에 대한 두가지 다른 해결책.
- DIP(의존관계 역전 원칙) : 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라. - DIP원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)

## 자바의 메모리 영역에 대해 설명
- https://yaboong.github.io/java/2018/05/26/java-memory-management/
- 자바의 메모리 공간은 1. 메소드 영역, 2. 스택 영역, 3. 힙 영역으로 구분 되고, 데이터 타입에 따라 할당됨.
### 메소드 영역
- 전역변수와 static변수를 저장하며, Method 영역은 프로그램의 시작부터 종료까지 메모리에 남아 있음.
### 스택 영역
- 지역 변수와 매개변수 데이터 값이 저장되는 공간. 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제. - LIFO구조, 변수에 새로운 데이터가 할당되면 이전 데이터 지워짐.
### 힙 영역
- new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장되며, 가비지 컬렉션에 의해 메모리가 관리됨.
- 힙 영역에 있는 데이터는 함수 내부에서 파라미터로 copied value를 받아서 변경하더라도 함수 호출이 종료된 시점에 변경내역이 반영되는 것을 볼 수 있다.
#### 힙 영역과 Immutable 변수 관계!
- 그러나 Immutable 변수는 반영이 안됨.  (String, Wrapper class...)
- Immutable 변수는 heap 에 있는 같은 오브젝트를 레퍼런스 하고 있는 경우라도, 새로운 연산이 적용되는 순간 새로운 오브젝트가 heap 에 새롭게 할당된다.
- Integer 클래스를 까보면 내부에서 사용하는 실제 값인 value 라는 변수가 있는데, 이 변수는 private final int value; 로 선언 되어있다
```java
public class Main {
    public static void main(String[] args) {
        String s = "hello";
        changeString(s); // String 불변객체 -> 변수 param은 함수 종료후 팝됨.
        System.out.println(s); // "hello"
    }
    public static void changeString(String param) {
        param += " world";
    }
}
```
### 각 메모리 영역이 할당되는 시점
- 메소드 영역 : JVM이 동작해서 클래스가 로딩될 때
- 스택 영역 : 런타임시 할당
- 힙 영역 : 컴파일 타임 시 할당

## Synchronized
- 여러개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 접근 막는 개념.

## String
### new String()과 리터럴("")의 차이
- new String()은 새로운 객체기 때문에 Heap 메모리 영역에 저장
- ""(리터럴)은 Heap안에 있는 String Constant Pool 영역에 저장.
### String, StringBuffer, StringBuilder의 차이
- String은 불변속성. StringBuffer, StringBuilder는 가변 속성
- StringBuffer 동지화지원 - 멀티쓰레드 환경에서 주로 사용
- StringBuilder는 동기화 지원하지 않아 싱글 쓰레드 환경에서 주로 사용.
### String 객체가 불변인 이유 
- 캐싱 기능에 의한 메모리 절약과 속도 향상 -> StringPool 이라는 공간에 저장. 참조하려는 문자열이 StringPool에 있는 경우, 새로 생성하지 않고 Pool이 있는 객체를 사용. -> 특정 문자열 값을 재사용하는 빈도가 높을수록 상당한 성능 향상.
- thread-safe
- 보안

## 클래스 멤버 변수 초기화 순서
- static 변수 선언부 : 클래스가 로드될 때 변수가 제일 먼저 초기화 됨.
- 필드 변수 선언부 : 객체가 생성될 때 생성자 block보다 앞서 초기화 됨.
- 생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking(thread-safe)

## static
- static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용할 수 있음. (인스턴스 생성 없이 바로 사용 가능)
- 모든 객체가 메모리를 공유한다는 특징이 있고, GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 떄까지 메모리에 값이 유지됨.
### static 사용 이유
- static은 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해 비용도 줄이고 효율을 높일 수 있음. 
- 인스턴스 생성 없이 바로 사용 가능하기 떄문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용함.

## Inner Class (내부 클래스)의 장점
- 내부 클래스에서 외부 클래스 멤버에 손쉽게 접근 가능.
- 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써 코드의 캡슐화를 증가 시킴
- 외부에서는 내부에 접근할수 없으므로, 코드의 복잡성을 줄일 수 있음.

## 리플렉션(Reflection)이란 무엇인가
- 리플렉션이란 구체적인 클래스 타입을 알지 못해도, 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API.
### 리플렉션 사용되는 경우
- 코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에서 지금 실행되고 있는 클래스를 가져와서 실행해야하는 경우에 사용됨
- 프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능이 제공. intelij 자동완성기능, 스프링 어노테이션이 리플렉션 활용한 기능.

## 컬렉션 프레임워크
- 다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합.

### Set과 Map 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 ?
- hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고, 해시코드 값이 다르다면 다른 객체로 판단하고, 해시 코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교함. 이 두개가 모두 맞으면 중복 객체

### Vector List 차이
- Vector는 동기화. thread-safe. 단일쓰레드 환경일 때도 동기화 하므로 List보다 성능 떨어짐.

## 제네릭
- 제네릭은 데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미.
- 제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지. 
### 장점
- 타입 안정성 : 컴파일 타입에 타입 체크하기 때문에 런타임에서 ClassCastException과 같은 UncheckedException을 보장받음.
- 타입체크와 형변환 생략 가능 : 코드 간결. 

## final / finally / finalize의 차이 설명
### final
- final은 클래스, 메소드, 변수, 인자를 선언할 때 사용할 수 있으며, 한 번만 할당하고 싶을 때 사용함. 
- final 메소드는 다른 클래스가 이 클래스를 상속할 때 메소드 오버라이딩을 금지.
- final 클래스는 다른 클래스에서 이 클래스를 상속할 수 없음.
### finally
- finally는 try-catch와 함께 사용되며 try-catch가 종료될 때 finally block이 항상 수행되기 때문에 마무리 해줘야 하는 작업이 존재하는 경우 해당 코드를 자겅해주는 코드 블록.
### finalize
- Object클래스에 정의되어 잇는 메소드이며, GC에 의해 호출되는 메소드로 절대 호출해서는 안되는 메소드. 

## 직렬화(Selialize)
- 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 바이트(byte)형태로 데이터 변환하는 기술.
- 반대로 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는 과정을 역직렬화 라고 함.
- JVM 메모리에 상주(힙or스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술.

### SerialVersionUID를 선언해야하는 이유
- JVM은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여하는데, 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당.
- 만약 직렬화할 때 사용한 SerialVersionUID의 값과 역직렬화 하기 위해 사용했던 SVUID가 다르다면 InvalidClassException이 발생할 수 있음. 





effective Java 에 나올법한 질문들,
* equals, hashCode 와의 관계가 어떻게 되느냐?
* JVM이 어떻게 구성되어 있고, 어떻게 동작하는지
* G1 GC 에 대한 것
* hash table, hash map 내부가 어떻게 구현되어있고, 어떤 연산을 하는지
* Thread-safe 한 것과 그렇지 않은 것
* StrintBuffer, StringBuilder 
Spring 에 대한 것
* Spring 내 Bean 의 생성 주기
# * Filter, Interceptor 가 언제 먼저 호출되는지, 어떤 순으로 되는지
- https://velog.io/@guswlsapdlf/Filter-vs-Interceptor
## Filter 
- 필터란 'HTTP 요청과 응답을 변경할 수 있는 재사용 가능한 클래스'
- 객체 형태로 존재, 클라에서 오는 요청과 최종 자원 사이에 위치하여, 클라의 요청 정보를 알맞게 변경 가능.
- 여러개의 필터가 모여 하나의 필터체인 형성 가능.
- filter는 스프링에서 관리되지 않고 톰캣과 같은 웹 컨테이너에 의해 관리됨. 필터를 추가하기 위해서는 Filter 인터페이스를 구현해주어야함.
- client에서 요청이 들어왔을 때 가장 먼저 요청을 맞이하는 곳. Spring Context 밖에서 정의되므로, Bean을 사용하는 비즈니소 로직과 관련된 작업은 수행할 수 없다. 인코딩, CORS, LOG, 인증 등을 구현 목적.
## Intercepter 
- 스프링에서 제공하는 기술로, Dispatcher Servlet에서 controller를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공.
- Spring context내부에 존재하므로 Spring의 모든 bean 객체에 접근 가능. 
- 먼저 Dispatcher Servlet은 Hadler Mapping을 통해 적정한 Controller를 찾는데, 그 결과로 실행 체인을 얻는다. 
- 이 실행 체인은 1개 이상의 Inteceptor가 등록되어 있을 경우, 순차적을 Interceptor들을 거쳐 controller가 실행되게 하고, interceptor가 없을 경우 바로 Controller를 실행.
- 그 다음, Dispatcher Servler은 실행할 Controller 정보를 Handler Adapter에 전달한다. Handler Adapter는 전달받은 Controller를 실행하는데, 실행하기 이전에 Interceptor들을 먼저 실행. 
- Handler Adapter가 Controller 메소드 혹은 interceptor를 실행하는 도중 HttpSession을 이용해야한다면, Servlet Container가 Session Storage를 확인하여 session을 새로 발급하거나 기존의 session을 매핑시켜줌.
- Interceptor를 추가하기 위해서 org.springframework.web.servelt의 HandlerInterceptor인터페이스를 구현.

## Filter VS Interceptor
- 필터와 인터셉터 공통점 : 요청을 처리하기 전, 전처리, 후처리를 해줌. -> 가장 큰 차이는 언제 처리 되는지
- 필터는 인터셉터보다 앞단에서 동작함, Spring과 무관한 작업의 처리도 가능.
### 관리되는 컨테이너
- 필터 : 웹 컨테이너
- 인터셉터 : 스프링 컨테이너
### Response/Request 조작 가능 여부
- 필터 : O
- 인터셉터 : X
### 용도
- 필터 : 보안 관련 공통 작업, 모든 요청에 대한 로깅 또는 감사, 이미지/데이터압출 및 문자열 인코딩.
- 인터셉터 : 인증/인가 등과 같은 공통 작업, Controller로 넘겨주는 정보의 가공. API호출에 대한 로깅 또는 검사. 
### 예시
- 1. 토큰에는 권한 정보만 지니고 있고, 권한으로 무엇을 할 수 있는지에 대한 정보는 DB에 저장되어 있을 때, 사용자의 권한에 따라 페이지에 접근을 막고자할 때 -> 인터셉터를 사용. 필터로 접근을 막으면 DB connectionPool이 2개 생겨서 비효율적. -> 스프링에서는 어차피 컨트롤러에서 요청을 처리할 때 디비 커넷션이 필요해서 커넥션 풀 생김, 그런데 필터 권한에 따른 페이지 접근 권한 막기 위해 디비를 조회하게 되어 커넥션 풀이 하나 더 생김.
- 2. IP에 대한 제한 둘 때 -> IP 정보는 ServletRequest로부터 제공되므로 Spring 무관하게 처리되므로 필터로 처리.

* MVC 패턴이 왜 탄생했는지?
* Spring Framework 이 왜 나왔는지? 이걸 통해서 무엇을 해결하려고 하는지
* JPA - 연관관계 매핑, n+1 문제, (언제 발생하고 어떻게 해결할 수 있고)
* 어디까지 DB를 사용하고 설계해봤는지 직접 그려봐라.

## SPRING

### 스프링 빈 스코프
- Bean의 사용 범위를 말하는 Bean Scope의 종류
- Bean은 스프링에서 사용하는 POJO기반 객체.
- 상황과 필요에 따라 Bean을 사용할 때 하나만 만들어야 할 수도 있고, 여러 개가 필요할 때도 있고, 어떤 한 시점에서만 사용해야할 때가 있을 수 있음.
- 이를 위해 Scope를 설정해서 Bean의 사용 범위를 개발자가 설정할 수 있음.
- 따로 설정해주지 않으면 Spring에서 Bean은 Singleton으로 생성됨. 싱글톤 패턴처럼 특정타입의 Bean을 딱 하나만 만들고, 모두 공유해서 사용하기 위함. 보통은 Bean은 이렇게 하나만 만들어서 사용하는 경우가 대부분.
#### 스프링 빈 스코프 종류
- sigleton : 해당 Bean에 대해 IoC 컨테이너에서 단 하나의 객체로만 존대.
- prototype : 해당 Bean에 대해 다수의 객체가 존재할 수 있음.
- request : 해당 Bean에 대해 하나의 HTTP Request 라이프사이클에서 단 하나의 객체로만 존재.
- session : 해당 Bean에 대해 하나의 HTTP Session의 라이프사이클에서 단 하나의 객체로만 존재.
- global session : 해당 Bean에 대해 하나의 Global HTTP Session의 라이프사이클에서 단 하나의 객체로만 존재.

### 스프링 시큐리티
#### 세션 기반 인증 vs 토큰 기반 인증
- 
#### jwt 토큰
- jwt토큰은 암호회된 3가지 데이터를 이어붙인 형태로 구성되어 있음. 
- 1.헤더 : 알고리즘(3번 서명값을 만듬), type(언제나 jwt)
- 2.페이로드 : 토큰이 갖는 데이터
- 3.서명 : 1번 헤더에 정의된 알고리즘을 통해 암호화한 비밀 값으로 서버만 알고 있음. 
#### jwt 단점
- 모든 사용자들의 상태를 기억x. -> 상태 제어 x. 
- 토큰 무효화 x -> 해결방법으로 accessToken, reFreshToken 두개를 줌. 그래도 accessToken 수명 동안은 바로 차단x.


### @RequestBody, @RequestParam, @ModelAttribute 차이 설명
#### @RequestBody
- @RequestBody는 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할.
- 값을 주입하지 않고 값을 변환 시키므로 **변수들의 생성자, getter, setter가 없어도 정상 할당됨**.
#### @RequestParam
- @RequestParam은 1개의 HTTP 요청 파라미터를 받기 위해 사용.
- @RequestParam은 필수여부가 true이기 때문에, 기본적으로 반드시 해당 파라미터가 전송되어야함. 
- 전송되지 않으면 400에러 유발될 수 있으며 반드시 필요 변수가 아니라면 required false 설정해주어야함.
#### @ModelAttribute
- @ModelAttribute는 HTTP Body 내용과 HTTP 파라미터의 값들을 생성자, 게터,세터를 통해 주입하기 위해 사용. 
- 값 변환이 아닌 값을 주입시키므로 변수들의 생성자나 게터, 세터가 없으면 변수들이 저장되지 않는다. 

### 스프링부트 vs 스프링
- 가장 큰 차이점은 Auto Configuration.
- 내장 톰캣으로 서버를 바로 실행.

### Spring MVC
#### Model
- 데이터 관리 및 비즈니스 로직을 처리하는 부분.
#### View
- 비즈니스 로직의 처리 결과를 통해 유저 인터페이스가 표현되는 구간. 
#### Controller 
- 사용자의 요청을 처리하고 Model과 View를 중개하는 역할. 
### MVC 관련 클래스
- DispatcherServlet : 클라이언트에게 요청을 받아 응답까지의 MVC 처리과정을 통제
- HandlerMapping : 클라이언트의 요청 URL을 어떤 Controller가 처리할지 결정. - @RequestMapping이 핸들러가 찾아주는역할.
- HanlderAdaptor : HandlerMapping에서 결정된 핸들러 정보로 해당 메소드를 직접 호출해주는 역할을 함.
- ViewResolver : Controller의 처리결과를 생성할 view를 결정. 
### MVC 요청 처리 순서
- 1. 클라이언트가 url을 요청하면, 웹 브라우저에서 스프링으로 request가 보내짐
- 2. Dispatcher Servlet이 request를 받으면, Handler Mapping을 통해 해당 url을 담당하는 Controller를 탐색 후 찾아냄.
- 3. 찾아낸 Controller로 request를 보내주고, 보내주기 위해 필요한 Model을 구성
- 4. Model에서는 페이지 처리에 필요한 정보들을 Database에 접근하여 퀴리문을 통해 가져옴.
- 5. 데이터를 통해 얻은 Model 정보를 Controller에게 response해주면, Controller는 이를 받아 Model을 완성시켜 Dispatcher Servlet에게 전달해준다.
- 6. Dispatcher Servlet은 View Resolver를 통해 request에 해당하는 veiw파일을 탐색 후 받아낸다.
- 7. 받아낸 View 페이지 파일에 Model을 보낸 후 클라이언트에게 보낼 페이지를 완성시켜 받아낸다.
- 8. 완성된 View파일을 클라이언트에 response 하여 화면에 출력.
#### 비슷하지만 조금 다른 설명
- 1. 클라이언트는 url을 통해 요청 전송
- 2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾음. 
- 3. 디스패처 서블릿은 핸들러 어댑처에게 요청의 전달을 맡김
- 4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달.
- 5. 컨트롤러 비즈니스 로직을 처리한 후에 반환할 뷰의 이름을 반환.
- 6. 디스패처 서블릿은 뷰 리졸버를 통한 반환할 뷰를 찾음
- 7. 디스패처 서블릿은 컨트롤러에서 뷰에 전달할 데이터를 추가.
- 8. 데이터가 추가된 뷰를 반환.

### 제어의 역전
- 제어의 역전이란 모든 객체에 대한 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것을 말함. 
- 스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입하는 역할을 하고 컨테이너에 등록한 객체들을 빈이라고 함.

### 의존성 주입
- 필요한 객체를 직접 생성하는 것이 아닌, 외부로부터 객체를 받아서 사용. 객체간의 결합도를 줄이고 코드의 재사용성 높임
- 생성자, 필드, 세터주입의 3가지 방법 -> 스프링에서 생성자 주입 권장.
- 생성자 주입 장점 : 1. 순환 참조를 방지, 2. 불변성을 가짐. 3.테스트에 용이


### 스프링에서 빈을 등록하는 방법 두 가지
- @Componenet 어노테이션을 사용(controller, service, repository 포함
- 설정 클래스를 만들어 @Configuration 어노테이션을 붙이고 해달 클래스에서 빈 등록 메소드 생성후 @Bean등록.

### 스프링 빈 라이프사이클 관리 순서
- 스프링 IoC 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 메소드 호출 -> 사용 -> 소멸 전 콜백 메소드 호출 -> 스프링 종료. 

### 롬복 라이브러리
- 메소드 생성 시점 : 롬복은 어노테이션 프로세싱을 통해 메소드 컴파일 과정에 개입하여 추가 코드를 만들어냄. 
- (롬복 라이브러리 추가할 때 CompileOnly, AnnotationProcessor를 추가하는 이유.)

### 서블릿
- 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술.
- Spring MVC에서 Controller로 이용되며, 사용자의 요청을 받아 처리한 후에 결과를 반환.
- 자바를 이용해 웹을 만들기 위해 필요한 기술. 
#### 서블릿 동작 방식 순서
- 사용자가 url 입력하면 http request가 Servlet Container로 전송됨.
- 요청 받은 Servlet Container는 HttpServletRequest, HttpServletResponse객체를  생성.
- web.xml을 기반으로 사용자가 요청한 url이 어느 서블릿에 대한 요청인지 찾음.
- 해당 서블릿에서 service 메소드를 호출, get, post 여부에 따라 doPost(), doGet()호출
- doPost(),doGet()메소드는 동적 페이지를 생성한 후 HttpServleResponse 객체에 응답을 보냄
- 응답이 끝나면 HttpServlerRequest, HttpServlerResponse 두 객체를 소멸. 

### VO, BO, DAO, DTO
- DAO는 DB의 데이터 접근을 위한 객체 (Repository 또는 Mapper)
- BO(Business Object)는 여러 DAO를 활용해 비즈니스 로직을 처리하는 객체 (Service)
- DTO 각 계층 간의 데이터 교환을 위한 객체를 말함 (계층 == Controller, View, BusinessLayer, Persistent Layer)
- VO 실제 데이터만을 저장하는 객체

### @Transactional의 동작 원리
- @Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy객체가 생성되며, Proxy 객체의 메소드를 호출하면 Target메소드 전 후로 트랜잭션 처리를 수행함.  

### JPA N+1 문제와 발생하는 이유 및 해결하는 방법
- N+1이란 1번의 쿼리를 날렸을 때 의도하지 않은 N 번의 쿼리가 추가적으로 실행되는 것을 의미. 
- 해결 방법에느 여러 방법이 있지만 가장 많이 사용되는 방법은 Fetch Join을 사용해 해결
- N+1 문제가 발생하는 이뉴는 연관관계를 가진 엔티티를 조회할 때 한 쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하기 때문인데, Fetch Join 사용하면 미리 두 테이블을 Join하여 한 번에 모든 데이터를 가져오기 때문에 N+1 문제를 애초에 막을 수 있음. 

## 관점 지향 프로그래밍(AOP)
- AOP는 핵심 비즈니스 로직에 있는 공통 관심사항을 분리하여 각각을 모듈화 하는 것을 의미하며, 공통 모듈인 인증, 로깅, 트랜잭션 처리에 용이. 
- 핵심 비즈니스 로직에 부가기능을 하는 모듈이 중복되어 분포되어 있을 경우 사용할 수 있음.
- AOP의 가장 큰 특징이나 장점은 중복 코드 제거, 재활용성의 극대화, 변화수용의 용이성 좋음.

## WAS와 WS 차이점
### WAS(Web Application Server)
- 비즈니스 로직을 넣을 수 있음
- Tomcat, PHP, ASP, .NET 등
### WS(Web Server) 
- 비즈니스 로직을 넣을 수 없음


# 프로그래밍 기본

## RestFul API
- 자원의 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것. 
- URI를 통해 자원을 명시하고 HTTP 메소드를 통해 해당 자원에 대한 crud 적용.
- ex) http://myweb/users
### 3요소 : Method, Resource, Message
#### Method
- POST, GET, PUT, DELETE
#### Resource
- 모든 것을 resouce(명사)로 표현하고, 세부 Resource에는 id를 붙임.
#### Message 포맷이 존재.
- json과 xml과 같은 포맷

### REST 특징
- https://gyoogle.dev/blog/web-knowledge/REST%20API.html

## 프레임워크와 라이브러리 차이
- 제어흐름에 대한 주도권이 누구에게 있는가.
- 프레임워크는 전채적인 흐름을 쥐고 있고, 개발자는 그 안에서 라이브러리에 대한 흐름을 쥐고 있음.
- 개발자의 제어권을 프레임워크에 넘김으로써 신경써야할 것을 줄일 수 있는데, 이를 제어의 역전이라 함.

## Call By Value와 Call By Reference의 차이. 
### Call By Value(값에 의한 호출) 
- 인자로 받은 값을 복사하여 처리하는 방식
- 장점 : 값을 복사하여 처리하기 떄문에 원래의 값이 보존됨.
- 단점 : 복사하기 때문에 메모리 사용량이 증가.
### Call By Reference(참조에 의한 호출)
- 인자로 받은 값의 주소를 직접 저장해 값에 영향을 주는 방식.
- 장점 : 복사하지 않고 직접 참조하기에 빠르다.
- 직접 참조하기에 원래의 값이 영향 받음. 
#### 자바에서는?
- 자바에서 기본적으로 모든 값 전달 방식이 Call by Value.
- 참조형의 경우 객체의 '주소값'을 매개변수로 전달하니 call by reference가 아니냐는 의문이 있을 수 있지만
- 정확하게 말하면 '주소값'이 아니라, '주소를 가리키는 참조값'임
- 또한 주소값 자체를 '복사 없이' 인자로 전달하는게 아니라 자기 자신이 갖고 있는 값을 복사해서 전달.
- 결국 기본형 변수나 참조현 변수 모두 자기 자신이 갖고 있느 값을 복사하여 전달하기 때문에 Call By Value임. 

## CORS (교차 출처 리소스 공유, Cross-Origin Resource Sharing)
- CORS란 도메인이 서로 다른 2개의 사이트가 데이터를 주고 받을 때 발생하는 문제
- 다른 서버의 리소스를 불러오기 위해서는, 그 출처에서 CORS에 대한 내용을 Response헤더에 추가해 주어야함.

## CSRF (Cross-site request forgery)에 대해 설명하고 이를 막기위한 방법 설명
- 사이트간 요청 위조의 약자
- 공격자가 의도한대로 사용자가 행동하게 하여 특정 웹페이지를 보안에 취약하게 한다거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법.
- 1. 사용자의 요청에 referrer를 확인하여 도메인이 일치하는지 확인(요청헤더에서 referrer정보 확인)
- 2. 상태를 변화시키는 POST, PUT 요청에 대해 csrf토큰이 포함되어야만 요청을 처리.


## 대칭키, 비대칭키 암호화
- 대칭키는 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘
- 비대칭키는 암호화와 복호화할때 서로 다른 키를 쓰는 알고리즘. -> 
-> 암호키를 가로채면 정보 유출 -> 타인애개 노출되어서는 안되는 개인키와 개방되어 있는 공개키 쌍. 
- 공개키로 암호화 하면 개인키로만 복호화 가능(공개키-공개키불가) & 개인키로 암호화하면 공개키로 복호화 가능.
- => 따라서 서버에서 개인키로 암호화한 암호문을 공개키로 복호화 하면 -> 서버가 개인키를 갖고 있는 인증된 서버인지 확인할 수 있음. 
- 공개키를 인증해주는 기업 CA(Certificate Authority) -> CA가 가진 공개키로 복호화 해서 서버를 인증. 
- 비대칭키로 처음 인증을 하게 되면 대칭키를 주고 받아서 그 다음부턴 대칭키 암호화(성능이 빠름)

# git
## merge vs rebase
https://www.atlassian.com/ko/git/tutorials/merging-vs-rebasing
https://firework-ham.tistory.com/12
https://brunch.co.kr/@anonymdevoo/7
- 공통점 : 하나의 브랜치에서 다른 브랜치로 변경사항을 통합하도록 설계.
- 

### merge
- 브랜치를 통합

### rebase
- 브랜치의 base를 옮김.
- -> 히스토리 관리가 편해짐. 



# 기술면접 준비 인강
## 자기소개
- 기술적인 자신감과 강점을 어필
- 대인관계에 대한 강점
- 최종적으로 지원하는 회사의 지원 직무에서 팀원들과 좋은 성과를 함께 낼 수 있을 것이라 생각하고 지원하게 되었다. 
- 전문성(개발지식), 협력(팀워크, 대인관계), 성장가능성(확장성)

## 백엔드 기술질문 대응
### 0. 일반 질문
- 1. 우리 사이트의 문제점은 어떤게 있는지 생각해본 적 있으신가요?
- 2. 본인이 생각하는 개발자의 가장 중요한 덕목이 무엇이라 생각하시나요? -> 합리화 하지 않는 자세.
- 3. 본인이 지원하신 직무에 대해 간략히 설명이 가능할까요? 
### 1. 공통 기술 질문 리스트 (5분에서 10분 설명해야함)
#### Spring AOP 란 무엇인가? (중요)
- 개념에 대해 아는 대로 설명
- joinpoint와 pointcut
- aspect 어노테이션에 대해 아는 것과 어느 시점에 사용해야 하는지?

#### Spring DI란 무엇인가? (중요)
 

####  Docker 관련 지식(컴포즈, 빌드, 컨테이너 구성)
- 만드는데 어떤 어려움이 있었는지?
- 도커에 대해 아는대로 얘기해보시겠어요?
- 도커 컨테이너 몇개로 운영해서 사용하셨었는지, 쿠버네티스 사용 경험에 대한 질문.

#### URI와 URL의 차이점
- URI(uniform resource identifier) : 상위, 논리적/물리적 리소스를 식별하는 고유한 문자열 시퀀스
- URL(uniform resource locater) : 하위, 웹주소

#### AES256과 SHA256 방식의 차이점을 아는대로 설명
#### AES256의 대칭 키 관리를 어떻게 하면 좋을지

#### JWT 보안 토큰 만든 이력이 있는 신입 개발자 질문
- JWT 인증을 하는 이유
- JWT의 토큰 구성에 대해 아는대로 이야기
- 헤더에 SHA256 알고리즘을 사용하는데 SHA256에 대해 아는대로 설명. AES256과의 차이점은 어떤게 있는가?  

#### 기타
- MVC패턴에 대해 알고 있는가?
- Restful API관련 알고 있는 지식이 있는지? - GET, POST, PUT, DELETE
- AWS 
- 뮤터블 이뮤터블 변수의 차이 
- Out of Memory
- 가비지 컬렉팅
- JVM의 heap과 stack의 차이 / 해당 영역에 쌓이는 데이터의 종류 
- 자바 자료구조 
- 동시에 만명이 결제한다면 분산을 어떻게 할 것인지? 
- 프로젝트 간 DB는 무엇을 사용. 

# 면접 기출문제 정리

## 1. Spring AOP에 대해서 설명.
### 공통 기능의 모듈화 
- 핵심기능, 부가기능. -> 부가기능을 여러곳에서 사용
- 공통기능을 '흩어진 관심사'라고 지칭. -> 흩어진 관심사를 모아서 모듈화를 시키는 것이 AOP
### 개념 정리
```
AOP란 간단하게 말하자면 관점지향 프로그래밍입니다.
관점지향 프로그래밍이란, 핵심적인 관점과 부가적인 관점(시간체크, 날짜체크, DB연결)로 나누어
핵심적인 비즈니스 로직과 반복해서 쓰이는 코드를 분리해서 개발하여, 반복적인 코드의 재사용을 늘리는 것입니다. 
```
### AOP 관련 어노테이션
#### @Aspect 
- 해당 클래스가 부가기능을 갖는 Class임을 알려주는 Annotation. 
- (aop의 개념 중 하나 )Advice : 부가 기능을 담은 구현체 - 어떤 기능을 언제 넣을 것인지.
- @Around("Pointcut") : 핵심관심사의 실패여부와 관계없이 전후로 실행되도록 하는 Advice
- 
```java
@Aspect
public class LogAop{
    @Around("execution(* com.java.ex.Car.accelerate(..))") // -> @Pointcut(상세스펙정의) - 어느 패키지인지
    public Object logging(ProceedingJointPoint jointPoint) throws Throwable{
        String methodName = joinPoint.getSignature().toShortString();
        try{
            System.out.println(methodName + "is Start.");
            Object obj =joinPoint.proceed();
            return obj;
        }finally{
            System.out.println(methodName + "is Finish.");
        }
    }
}
```
- Target : aspect 적용하는 곳.
- Joinpoint : advice의 적용위치.

### Spring DI
- DI 적용 안된 코드
```java
class A{
    private B b;
    public A(){
        b = new B();
    }
}
```

- DI 적용

```java
class A{
    private B b;
    public A(){
    }
    public void setB(B b){ // 스프링 컨테이너가 생성. 컨테이너라고 부르는 JVM의 메모리 영역에 저장되어있음.
        this.b = b;
    }
}
```

- -> 수정이 일어날 경우 DI 적용된 코드가 종속성이 낮기 때문에, 업데이트할 클래스만 수정. 
```
- Spring DI란 무엇인가요?
- DI란 Dependency Injection이라고 부릅니다.
객체지향 프로그래밍은 컴포넌트들의 조합인데요, 이 컴포넌트들의 의존관계를 만들어주는 작업이 Dependency Injection이라고 부릅니다.
Dependency Injection은 크게 setter를 통한 조립과 constructor를 통한 조립이 있습니다. 

- DI가 왜 중요한가?
- 일체형보다는 조립형이 종속성이 적습니다. 수정사항으로 인한 업데이트 같은 이슈가 발생 시 종속성이 높을수록 체크리스트가 많아지고 오류의 발생빈도가 점차 높아짐. 
```

# 공통 질문 대응 및 기타 노하우 
- 1. 정말 대답하기 어려운 질문을 받았을 때 -> 최대한 대답을 짜내기....
- 2. 개발과정에서 기획자와의 의견충돌이 있을 때 어떻게 할 것인지 -> 
-> 회사업무라는 것은 혼자가 아닌 함꼐 해나가는 업무이기 때문에 내가 무조건 옳다고 생각하지 않고 의사소통하겠다. 논리적인 방식으로 건전한 토론을 통해 상호 의견을 맞춰가는 방식으로 하면 될 것이라고 생각한다. 
- 3. 마지막으로 하고 싶은 말 꼭 준비. 

## 데이터베이스 관련 문제 
- 예시 ) https://velog.io/@guswlsapdlf/e-shop-%EC%9D%B4%EC%BB%A4%EB%A8%B8%EC%8A%A4-%ED%86%A0%EC%9D%B4-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-ERD-%EC%84%A4%EA%B3%84
- 10분 정도의 시간을 제공하고 상세한 스펙을 말해준 뒤 프로모션 서버를 구축해보라고 문제를 냄
- db erd
- 서버 구성
- 서버 운영

### rdbms erd 
#### 프로모션 마스터 테이블
- Prom_id, Prom_nm, start_dts, end_dts, reg_id, reg_dt, mod_id, mod_dt
#### 프로모션 히스토리 (프로모션 마스터 테이블과 1:n 관계)
- idx, prom_id, Prom_nm, strt_dts, end_dsts, reg_id, reg_dt, mod_id, mod_dt
#### 상품 프로모션 
- prom_id, item_id, prom_kind, prom_way, dc_amt
#### 장바구니 프로모션
- prom_id, cart_info(금액, 회원, 쿠폰 등), cart_info_detail,  

## 데이터베이스 기타
### Clustered Index와 Non Clustered Index 차이점 
- pk가 기본적으로 Cluster Index -> 캐시 메모리에 저장 
- Non Clustered Index -> 인덱스를 지정.
### DB의 정규화 비정규화 역정규화에 대해서 설명 (반드시 출제)
#### 비정규화
- 비정규화는 정규화된 데이터의 중복을 허용
#### 역정규화
- 정규화 하기 이전 상태를 사용 -> 정규화를 했을 경우 조인 연산이 발생, 디비의 리소스를 사용하기 떄문에 리소스를 적게 사용하기 위해 역정규화를 쓸 수 있으나 운영하는 측면에서는 비효율적. 복합해짐. 
- DB의 읽기 수준에 대해 아는대로 이야기
- 동시성 제어에 관해 설명(3년차)

## 네트워크 관련 문제
- 사이트 접속 프로세스(중요)
- ip address / mac address 차이
- tcp/ip에 대해 아는대로 설명
- Handshaking이 client/server 간에 일어나는 과정을 설명
- Keep alive에 대해 아는대로 설명

### 1. 사이트 접속 프로세스
- www.naver.com에 들어오기까지의 과정 모두 설명
- 1. url 입력
- 2. dns에 ip 주소 요청 (이 전에 내부 한번 검색하는데..) => dns server(skt,kt,lgu+)
- 3. dns ip 주소 응답 (ex-223.130.195.95)
- 4. ARP(Address resolution protocol) : 브로드캐스트 방식을 통해 223.130.195.95의 mac address(실제물리서버주소)가져옴
- cf) arp cache - 같은 망대역에 있는 ip들에 대해서 mac adress주소 요청 
- 5. 소켓 열기 : TCP 소켓 스트림 요청 (3-way handshake) => syn -> syn+ack -> ack
- 5. (https 사용할 경우 )=> TLS handshake 
- 6. HTTP 프로토콜 : 서버에서 요청받아 HTML 및 데이터 전송 (응답)
#### 정리
- 1. url 입력 -> dns 서버에서 ip address 받아옴
- 2. (arp)목적지의 mac주소 확인 
- 3. 소켓 오픈
- 4. TLS handshake
- 5. http 프로토콜 작동
- 6. 웹 브라우저가 리소스(HTML, CSS, JS)를 브라우저 제공 및 표시 

### 팁 
- 프로젝트 트러블슈팅 과정에서 네트워크 이슈 -> 과정에서 얻게된 네트워크 지식을 어필. 

# 좋았던 지원자와 아쉬웠던 지원자
- 지원동기
- 공부를 안한 느낌이 많이 듬. (스프링 면접 준비 많이 하기... -> 어떤 기술(라이브러리)를 사용했는지 자세히 분석. )
- 준비성이 떨어짐 (자기소개 너무 짧을 경우)
- spring : IoC , api documentaion (스웨거,, 내가 했던게 spring doc) 


# 프로레스 VS 쓰레드
## 프로세스
### 프로세스의 개념
- 실행 중인 프로그램(A program in execution)
- 사용자 관점에서 세그먼트(Code, Data, Stack)의 가상 주소를 갖는 실행 상태
- 메모리 영역에 자신의 주소 공간을 가져 CPU를 할당받을 수 있는 실행 프로그램
### 프로세스의 주소공간
- 실행 스택(Stack) : 호출된 프로시저(함수)의 복귀주소와 지역변수와 같이 일시적인 데이터를 저장하는 영역.
- 실행 힙(Heap) : 코드 영역과는 별도로 유지되는 자유영역. 프로세스 실행 중에 동적으로 할당되는 메모리 영역으로 시스템 호출을 통해 사용되다가 해지되는 등 자유자재로 사용한다.
- 데이터 (Data) : 프로세스 실행 중에 동적으로 할당받는 영역으로 전역 또는 정적 변수를 저장한다. 읽고 쓰기가 가능하다.
- 코드(Code) : 프로세서(CPU)가 실행하는 코드를 저장하는 영역. 프로그램이 코드 영역을 침범하여 기록하려고하면 오류가 발생하고 프로그램은 종료된다.
### 프로세스 제어 블록(Process Control Block, PCB)
- 운영체제가 각 프로세스를 관리하기 위해 프로세스 당 유지하는 데이터 블록 또는 데이터 구조.
- 프로세스 생성과 동시에 함께 고유한 PCB가 생성되며 프로세스가 종료되면 PCB도 함께 삭제된다.
- PCB의 정보는 인터럽트 처리, 자원 할당, 스케줄링 등을 수행하는 운영체제의 모든 모듈이 읽고 수정할 수 있다.
- 문맥교환(Context Switch)이 발생할 때마다, 진행하던 프로세스의 정보가 PCB에 저장되고 다시 실행할때 PCB에 저장된 애용을 불러와 중지되었던 시점부터 다시 작업을 수행한다. 
#### 프로세스 제어 블록의 구성요소
##### 1. O/S가 관리상 사용하는 정보
- 프로세스 상태(Process State) : new, ready, running, waiting, terminated등의 상태를 저장.
- 프로세스 식별자(PID)
- 프로세서 스케줄링 정보(Scheduling inormation) : priority, pointer, 스케줄 매개변수 등
- 계정 정보 : 프로세서 사용시간, 실제 사용시간, 사용상한시간, 계정 번호, 작업이나 프로세스 변호 등
##### 2. CPU 수행 관련된 하드웨어 값
- 프로그램 카운터, 레지스터 저정영역
##### 3. 메모리 관련 정보
- Code, Data, Stack, Heap의 위치정보
##### 4. 파일 관련 정보
- 개방된 파일목록, 특별한 입출력 요구 프로세스에 할당된 입출력 장치 등
 

 ## 스레드
 ### 스레드의 개념
- 프로세스의 실행 단위 ("A basic unit of CPU utilization")
- CPU를 사용하는 기본 단위이면서, 프로그램을 실행하는 프로세스 내의 개체, 명령어를 독립적으로 실행할 수 있는 하나의 제어 흐름.
- 프로세스는 하나 이상의 스레드를 가진다.
- 하나의 프로세스의 수행단위(PC)를 여러개 두는 것 -> 멀티 스레딩
- 스레드는 같은 그룹의 스레드와 코드, 주소 공간, 운영체제 자원등을 공유한다.
- 다중 스레드를 통해 처리율이 증가해 성능이 향성되고 병렬성이 증가한다. 

### 스레드의 구조
- 스레드 실행 시 상태
- 실행 스택
- 지역 변수와 스레드의 특정 데이터를 저장하기 위한 스레드별 정적 저장소
- 프로세스의 다른 스레드가 공유하는 메모리와 자원에 대한 접근 같은 스레드 실행 환경 정보(Context Information) 
: PC(Program Counter), SR(Sequence Register), SP(Stack Pointer)

### 스레드 이용 시 이점
- 사용자에 대한 응답성 증가
: 다중 스레드 환경에서는 하나의 스레드가 blocked 상태인 동안 (예를 들어 입출력을 하는 동안) 다른 스레드가 실행되어 다른 작업을 빨리 처리하면서 사용자와 상호작용이 가능하다.
: 프로세스의 자원과 메모리 공유 가능
- 스레드는 한 프로세스의 자원을 공유하기 때문에 하나의 같은 주소 공간에서 여러 개의 스레드를 실행해 시스템 성능을 향상시킨다. ->병렬성, 성능향상
: 경제성 
- 스레드는 한 프로세스의 자원을 공유하기 때문에, 메모리와 자원을 할당해 프로세스를 생성하는 것보다 스레드끼리 문맥 교환 하는 것이 오버헤드가 적다.
: 다중 프로세서 구조 활용 가능
- 다중 프로세서 구조에서 각 스레드는 다른 프로세서성에서 병렬로 실행될 수 있따.

### Stack과 PC Register를 스레드마다 독립적으로 할당하는 이유
- stack은 프로시저의 복귀 주소나, 지역 변수같이 일시적이고 독립적인 실행환경을 제공한다. 스레드는 하나의 독립적인 실행 단위이기 때문에 각각 해당 실행에 대한 독립적 stack을 가진다. 
- 스레드는 프로세스와 같이 CPU를 할당받고, 선점당할 수 있다. 따라서 문맥교환이 발생하게 되므로 실행하고 있는 코드의 지점을 저장하는 PC Register는 스레드마다 독립적으로 할당되어야 한다. 

# 모던 자바 인 액션(람다, 스트림, 함수형)

## 컬렉션 vs 스트림

### 외부반복(컬렉션) vs 내부반복(스트림)

- 컬렉션에서는 반복과정을 직접 처리.
- for-each루프를 이용해서 각 요소를 반복하면서 작업을 수행 => 외부 반복
- 스트림에서는 루프를 신경쓸 필요 없이 라이브러리 내부에서 모든 데이터가 처리됨 => 내부 반복

### 스트림 특징

- 반복되는 패턴을 라이브러리로 제공 + 병렬화
- 필터링
- 추출
- 그룹화
- 포킹

## 중점

- 컬레션은 데이터를 어떻게 저장하고 접근할 지 중점을 둠
- 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는데 중점을 둠. + 병렬로 처리.

## 스트림 처리

- 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임.
- 스트림 패키지에 정의된 Stream\<T\>는 T 형식으로 구성된 일련의 항목을 의미.
- 스트림 API가 조립 라인처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 단순하게 생각하자.

## 스트림 API

- 스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 이것을 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있게 됨.
- 스트림 파이프라인을 이용하여 입력 부분을 여러 CPU코어에서 쉽게 할당.(병렬성)

### 동작 파라미터화로 메서드에 코드 전달하기

- 코드 일부를 API로 전달하는 기능
- 메서드(우리코드)를 다른 메서드의 인수로 넘겨주는 기능 => "동작 파라미터"화.

### 병렬성과 공유 가변 데이터.

- 병렬성을 공짜로 얻을 수 있다. 다만, 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야함.

### 정리 : 함수형 프로그래밍의 핵심사항

- 1. 공유되지 않은 가변데이터
- 2. 메서드, 함수 코드를 다른 메서드로 전달

### 메서드 참조

```java
// 기존
File[] hiddenFiles = new File(".").listFiles(new FileFilter(){
    public boolean accept(File file){
        return file.isHidden(); //숨겨진 파일 필터링
    }
});

// 메서드 참조 사용
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

- 메서드 참조(이 메서드 값으로 사용하라라는 의미)를 이용해서 listFiles에 직접 전달할 수 있다.

### 람다 (익명함수)

- 자바에서는 메서드를 일급값으로 취급할 뿐 아니라, 람다(익명함수)를 포험하여 함수도 값으로 취급할 수 있다.
- 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결하게 코드 구현 가능.

## 스트림 시작하기

### 스트림 정의

- 스트림이란 '데이터처리 연산'을 지원하도록 '소스'에서 추출된 '연속된 요소'로 정의 가능.

#### 연속된 요소

- 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공.
- 컬렉션은 자료구조이므로 컬렉션에서는 시간, 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룸
- 스트림은 filter, sorted, map처럼 표현 계산식이 주를 이룸.
- 컬렉션의 주제는 '데이터', 스트림의 주제는 '계산'.

#### 소스

- 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비.
- 정렬이 그대로 유지됨.

#### 데이터 처리 연산.

- filter, map, reduce, find, match, sort 등으로 데이터를 조작. 순차적으로 또는 병렬로 실행 가능

### 스트림 특징

#### 파이프라이닝

- 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환함.

#### 내부 반복

- 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원.

### 스트림 예시

- filter : 람다를 인수로 받아, 스트림에서 **특정 요소를 제외**.
- map : 람다를 이용해서 한 요소를 다른 요소로 **변환하거나 정보를 추출**함.
- limit : 스트림의 크기를 축소.
- collect : 스트림을 다른 형식으로 변환.

### 컬렉션과 스트림의 가장 큰 차이.

- 1. 데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이이다.
- 2. 데이터 반복 처리 방법

### 데이터를 언제 계산 하느냐.

#### 컬렉션

- **컬렉션**은 현재 자료구조가 포함하는 **모든 값을 메모리에 저장**하는 자료구죠.
- 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야함.

#### 스트림

- **스트림**은 이론적으로 **요청할 때만 요소를 계산하는 고정된 자료구조**.
- 스트림에 요소를 추가하거나 스트림에서 요소를 제거할 수 없다.
- 사용자가 요청하는 값만 스트림에서 추출한다는 것이 핵심.
- 스트림은 생산자와 소비자 관계를 형성.
- 게으르게 만들어지는 컬렉션과 같다. 즉, 사용자가 데이터를 요청할 때만 값을 계산한다.

#### 한 번만 탐색 가능

- 반복자와 마찬가지로 스트림도 한 번만 탐색할 수 있음.

### 데이터 반복 처리 방법이 어떻게 다른가

#### 외부 반복과 내부 반복

## 스크림 연산 - 중간 연산 vs 최종 연산

### 중간 연산

- filter()나 sorted()같은 중간 연산은 다른 스트림은 반환한다.
- 따라서 여러 중간 연산은 연결해서 질의를 만들 수 있다.
- **중간 연산의 중요한 특징**은 단말 연산을 스트림 파이프라인에 실행하기 전까지 아무 연산도 수행하지 않는다는 것.
- 즉 게으르다는 것.
- 합쳐진 중간 연산을 최종연산으로 한 번에 처리.

#### 중간 연산으로 알아보는 스트림 최적화

- 쇼트서킷
- 루프 퓨전

```java
List<String names> =
    menu.stream()
    .filter(dish->{
        System.out.println("filtering : + dish.getName());
        return dish.getCalories() > 300;
    })
    .map(dish ->{
        System.out.println("mapping: " + dish.getName());
        return dish.getName();
    })
    .limit(3)
    .collect(toList());
System.out.println(names);
//filtering:pork
//mapping:pork
//filtering:beef
//mapping:beef
//filtering:chicken
//mapping:chicken
//[pork, beef, chicken]
```

- 스트림의 게으른 특성 때문에 몇가지 최적화 효과를 얻을 수 있음.
- 300칼로리가 넘는 요리는 여러개 이지만 오직 처음 3개만 선택됨 => limit연산, 쇼트서킷이라 불리는 기법 덕분
- filter, map은 다른 연산이지만 한 과정으로 병합됨(루프 퓨전)

### 최종 연산

- 최종 연산은 스트림 파이트라인에서 결과를 도출한다.
- 보통 최종연산에 의해 List, Integer, void 등 스트림 이외의 결과가 변환된다.

## 스트림 이용하기

- 스트림 이용 과정은 다음과 같이 세가지로 요약할 수 있다.
- 1. 질의를 수행할 (컬렉션 같은) 데이터 소스
- 2. 스트림 파이프라인을 구성할 중간 연산 연결
- 3. 스트림 파이프라인을 실행하고 결과를 만들 최종 연산.
- 스트링 파이프라인의 개념은 빌더 패턴과 비슷한다.
- 빌더 패턴에서는 호출을 연결해서 설정을 만든다. (스트림에서 중간 연산 연결)
- 준비된 설정에 build 메서드를 호출 (스트림에서는 최종 연산에 해당)

### 중간연산 최종연산 예

#### 중간 연산

```
연산      형식       반환형식      연산의 인수        함수 디스크립터

filter   중간연산    Stream<T>   Predicate<T>    T -> boolean
map      중간연산    Stream<R>   Function<T, R>  T -> R
limit    중간연산    Stream<T>
sorted   중간연산    Stream<T>   Comparator<T>   (T, T) -> int
distinct 중간연산    Stream<T>
```

#### 최종 연산

```
연산      형식       반환형식         목적
forEach  최종연산    void           스트림의 각 요소를 소비하면서 람다를 적용한다.
count    최종연산    long(generic)  스트림의 요소 개수를 반환한다.
collect  최종연산                   스트림을 리듀스해서 리스트, 맵, 정수 형식의 컬렉션을 만든다.


# ArrayList VS LinkedList 

<img width="1069" alt="스크린샷 2022-07-13 오전 9 20 13" src="https://user-images.githubusercontent.com/68639744/178623357-ace870bb-3fd9-4d53-9e6d-1189a8d166ce.png">

- java에서 기본형 또는 인스턴스를 저장하기 위해 보통 배열을 사용.
- 하지만 배열의 초기길이를 지정해야 하며, 생성된 배열의 길이는 동적으로 변경할 수 없음.
- 이에 대한 대안으로 List인터페이스를 구현한 ArrayList와 LinkedList를 사용.
### 동기화 이슈
- List는 Thread-safe를 개발자가 고려해야하며 필요하다면 아래와 같이 Collections 클래스를 통해 동기화 제공하는 List 생성 가능.
```java
Collections.synchronizedList(List\<T\> list);
```

## ArrayList
<img width="257" alt="image" src="https://user-images.githubusercontent.com/68639744/178623507-2aa3a3c2-3499-4a01-9d40-05997a840334.png">

- 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해 임시 배열을 생성해 데이터를 복사.
- -> 대량의 데이터 추가/삭제 하는 경우에는 데이터 복사가 많이 일어나게 되어 성능저하. 최악 O(n)
- -> 반면 각 데이터 인덱스 가지므로 한번에 참조가 가능해 데이터 검색에 유리 O(1)

## LinkedList
<img width="496" alt="image" src="https://user-images.githubusercontent.com/68639744/178623624-4ca503c5-858b-4253-8a0f-fece21b45608.png">

- 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있음.
- -> 데이터 복사가 없어 데이터의 추가, 삭제에 유리 O(1)
- -> 데이터 검색시 처음부터 순회해야하므로 성능상 불리. 최악 O(n)
- 또다른 단점은 데이터가 메모리에 산재해 저장되기 때문에 참조자를 위한 추가적 메모리 할당이 필요.
<br/><br/><br/><br/><br/>


# HashSet VS HashTable
- https://d2.naver.com/helloworld/831311


<br/><br/><br/><br/><br/>


# String

- 자바의 문자열은 String 클래스의 인스턴스로 관리 됨. 소스 상에서 문자열 리터럴(데이터 값)은 String 객체로 자동 생성되지만, String 클래스의 생성자를 이용해서 직접 String객체를 생성할 수도 있다. 

### split() vs StringTokenizer
: 문자열이 특정 구분자(delimiter)로 연결되어 있을 경우, 구분자를 기준으로 부분 문자열을 분리하기 위해서는 String의 split() 메소드를 이용하거나, java.util 패키지의 StringTokenizer 클래스를 이용할 수 있다. split()은 정규 표현식으로 구분하고, StringTokenizer는 문자로 구분한다. 

``` java
String[] result = "문자열".split("정규표현식");
```

- split() 함수는 문자열 배열을 리턴한다.

```java
StringTokenizer st = new StringTOkenizer("문자열", "구분자");
```
- 구분자를 생각하면 공백이 기본 구분자가 된다. 
- 메소드들을 이용해서 전체 토큰 수, 남아 있는 토큰 여부, 토큰을 읽기

```java
String text = "홍길동/이수홍/박연수";

// 방법 1. 전체 토큰 수를 얻어 for 문으로 루핑
StringTokenizer st = new StringTokenizer(text, "/");
int countTokens = st.countTokens(); //토큰 수 얻기
for(int i = 0; i<countTokens; i++){
	String token = st.nextToken(); //토큰 하나 꺼내오면 st에 해당 토큰 사라짐.
	System.out.println(token);
}

// 방법 2. 남아 있는 토큰을 확인하고 while문으로 루핑
st = new StringTokenizer(text, "/"); //위의 st는 다 사용했기 때문에 새로 생성
while(st.hasMoreTokens()){
	String token = st.nextToken();
	System.out.println(token);
}
```

<br><br><br/><br/><br/>

# StringBuffer, StringBuilder
- String은 문자열이 변경되면 새로운 객체를 생성하기 때문에 성능이 낮아짐.
- 문자열 변경 작업이 많을 경우엔 StringBuffer나 StringBuilder 클래스를 사용.
- 두 클래스는 내부 버퍼에 문자열을 저장해두고, 그 안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있음.
- StringBuffer는 동기화 적용되어 스레드에 안전.
- StringBuilder는 동기화 x. 단일 스레드환경에서만 사용해야함.
<br/><br/><br/><br/><br/>


# 캡슐화

캡슐화란?

캡슐화(encapsulation)는 객체 지향 프로그래밍에서 다음 2가지 측면이 있습니다.
객체의 속성(data fields)과 행위(메서드, methods)를 하나로 묶는다.
실제 구현 내용 일부를 외부에 감추어 은닉한다.

# 접근제어자
자바에는 변수와 함수, 클래스에 대한 접근을 제한하는 문법이 있습니다. 접근을 제한하는 이유는 객체가 가진 고유의 멤버 변수값들이 외부에서 잘못 변경되는 것을 막기 위해서입니다. 사전에 멤버 변수와 함수들의 성격을 규정하고 차단함으로써 의도치 않은 실수를 줄이기 위한 의도가 깔려 있습니다. 총4가지가 있는데 public 과 private 를 가장 많이 사용합니다.


# 상속
자바에는 상속(Inheritance)이라는 개념이 존재합니다.

쉽게 말해 부모 클래스(상위 클래스)와 자식 클래스(하위 클래스)가 있으며, 자식 클래스는 부모 클래스를 선택해서, 그 부모의 멤버를 상속받아 그대로 쓸 수 있게 됩니다.

상속을 하는 이유는 간단합니다. 이미 마련되어 있던 클래스를 재사용해서 만들 수 있기 때문에 효율적이고, 개발 시간을 줄여주게 됩니다.

상속을 하더라도 자식 클래스가 부모의 모든 것들을 물려받는 것은 아닙니다

1. reflection 관련 클래스들

자바 API에는 reflection이라는 패키지가 있다. 이 패키지에 있는 클래스들을 사용하면 JVM에 로딩되어 있는 클래스와 메서드를 정보를 읽어 올 수 있다. 주요 클래스의 종류와 각 클래스에서 제공되는 메서드에는 어떤 것들이 있는지 간단히 알아보자.


# 정보은닉

정보 은닉(information hiding)
정보 은닉은 private 키워드를 활용해서 외부에서 클래스 내부의 정보에 접근하지 못하도록 하는 기능을 말합니다.
private 변수를 외부에서 접근하게 하려면 public 메서드를 사용하여 값을 입력하거나 읽을 수 있습니다. 이는 클래스 내부의 데이터를 잘못 사용하는 오류를 방지하기 위해 사용 됩니다.

# 내부 클래스

내부 클래스?

내부클래스는 클래스 내에 선언된 클래스다. 클래스에 다른 클래스를 선언하는 이유는 두 클래스가 서로 긴밀한 관계에 있기 때문이다.

내부 클래스의 장점

내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
코드의 복잡성을 줄일 수 있다.
* * * 
* * * 
* * * 




# 코딩테스트 유형 (simple)
## 1. 정렬
- 정렬 문제 단독으로 나오는 경우 거의 없음.
- 풀이를 위한 사전 과정. 
- 버블, 선택, 퀵, 합병, 우선순위 큐 ...

## 2. 탐색
- 주어진 데이터에서 특정 값 찾기 (2차원/3차원 데이터에서 인접한 /가능한 경로 찾기)
- 단순 풀이로 접근 시 대부분 시간초과로 실패
- 완전, 이진, 투 포인터, BFS, DFS ...

## 3. 부분 문제의 합 - 분할정복/DP 
- 최대 값 찾기 / 부분 수열의 최대 길이 / 0-1Knapsack 문제 ...
- 단순 반복, 조건문 나열로는 풀기 복잡한 문제
- 해귀함수를 통한 작은 문제의 반복적 해결 구조 또는 계산 결과의 재사용
- 분할정복 , DP

## 4. 최적선택 - 그리디
- Activity Selection / 거스름돈
- 특정 조건 만족 시 빠르게 문제를 해결할 수 있는 방법
- 최적해가 아닌 근사치를 얻을 수도 있으므로 사용 시 주의 필요
- 그리디 

## 5. 기타 시뮬레이션
- 조건에 따른 문자열 입력/삭제/수정 문제
- 문제의 요구사항을 잘 읽고 해결하는 문제
- 특정 알고리즘 분류로 매핑되지 않는 경우 많음 


# 3-3 학습환경 구성 - Tool 사용
- 디버깅 사용방법 
- 중단점, 
- Step over: 한줄 씩 이동. 함수를 타고 들어가진 않음. 
- Step Into: 하위구조를 타고 들어감. 
- Step Out: 들어왔던 하위구조를 나감 

# 자바
## 자바 프로그램 작성 실행 과정
- 자바소스코드 - 자바컴파일러 - 바이트 코드 - jvm - 실행
# 변수와 자료형
- 변수 : 데이터를 저장하는 메모리 공간에 붙여준 이름
# 자료형
## 숫자형
- 정수 / 실수 / 2진수, 8진수, 16진수
```java
//2진수 0b~
int numBase2 = 0b1100;
System.out.println("0b" + Integer.toBinaryString(numBase2)); //2진수로출력
//8진수 0~
int numBase8 = 014;
System.out.println("0" + Integer.toOctalString(numBase8));//8진수로출력
//16진수 0x~
int numBase16 = 0xC;
System.out.println("0b" + Integer.toHexString(numBase16));//16진수로출력
```

- 실수
```java
float floatNum = 1.23f; //뒤에 f 붙이기
double doubleNum = 1.23;
```

## 문자열
- equals(), indexOf(), replace(), substring(), toUpperCase()
```java
String s3 = "Hi";
String s4 = "Hi";
String s5 = new String("Hi");
System.out.println(s3.equals(s4)); //true
System.out.println(s3 == s4); //true
System.out.println(s3.equals(s5)); //true
System.out.println(s3 == s5); // false
```

## 자료형: StringBuffer
- 문자열을 자주 추가하거나 변경할 때 사용하는 자료형
- 문자열은 데이터가 변경될 때마다 객체가 변하지만, StringBuffer는 객체 안에서 변경됨 ..?
```java
StringBuffer sb1 = new StringBuffer("HelloWorld!"); 
sb1.append("1234"); 
```
- append(), insert(), substring()

## 자료형 : 배열
## 자료형 : 리스트
- add(), get(), size(), remove(), clear(), sort(), contains()
```java 
ArrayList l1 = new ArrayList(); //아무 자료형이나 넣을 수 있었네..??
l1.add(1);
l1.add("hello");
l1.add("world!");
System.out.println("l1 == " + l1); // l1 = [1, "hello", "world!"]

l1.add(0, 1); // (index, element)
System.out.println("l1 == " + l1); // l1 = [1, 1, "hello", "world!"]->추가됨

//remove
l1.remove(0); // 인덱스 0번 지우기
l1.remove(Integer.valueOf(2)); // int 2 값 찾아서 지우기 

//clear
l1.clear() // 모든 데이터 지우기 

//sort
l1.sort(Comparator.naturalOrder()); //오름차순
l1.sort(Comparator.reverseOrder()); //내림차순

//contains(element) //데이터 존재 유무 true || false 
```
## 자료형 : 맵
- put(), get(), size(), remove(), containsKey()
```java
map.remove("key") // 값 있었으면 출력 || 없었으면 null 출력 
```
## 자료형 : 제네릭스
- 자료형을 명시적으로 지정
- 제한적일 수 있지만 안정성을 높여주고 형변환을 줄여줌. 
- ArrayList, Map 등 제네릭 사용안하면 하나의 자료구조에 다양한 타입 저장가능. 


# 연산자
- 단항 연산자, 이항 연산자, 삼항 연산자.
- 대입 연산자
- 부호 연산자
- 산술연산자
- 증가/감소 연산자 
- 관계 연산자
- 논리 연산자 
- 복합 대입 연산자 

## 2진법 비트연산자
- 2의 보수 : 2의 제곱수에서 뺴서 얻은 이진수 
- 자리 올림이 필요한 만큼의 수. 
- ex)2진수 3의 2의 보수 : 11 -> 01 
- => 11에서 자리올림(100)이 되려먼 01을 더해야함.
- 2의 보수로 음수 표현을 하기도 함 (자릿수를 올려서 0 비트로 만들기)

## 비트연산자
- 기본연산자 -> && , || 
- 비트연산자 -> & , | 
- & : 두 개의 비트가 모두 1인경우에만 1
- | : 두 개의 비트값 중 하나라도 1이면 1
- ^ (XOR 연산자) : 같으면 0 다르면 1 
- ~ (반전연산자) : 0을 1으로, 1을 0으로 
 
``` java
int num1 = 5;
result = ~num1;
System.out.println("result = " + result); // -6
System.out.printf("%04d\n", Integer.parseInt(Integer.toBinaryString(num1)));
// => 0101
System.out.printf("%s\n", Integer.parseInt(Integer.toBinaryString(result)));
// => (앞에 1 28개)1010 ==> 32비트에 나머지 앞의 자리가 1(부호)로 전부 바뀌었음 
```
- 비트이동연산자 (\<\<, \>\>, \>\>\>)
- \<\< :비트를 왼쪽으로 이동 
- 3\<\<1  =>  0011 => 0110 (\*2의 효과)
- \>\> : 비트를 오른쪽으로 이동
- 3\>\>1 => 0011 => 0001  (/2의 효과)
- \>\>\> : 연산자 
- 비트를 오른쪽으로 이동(부호비트 상관없이 0으로 채움) 
```java
numA = -5;
result = numA >> 1;
System.out.printf("%s\n", Integer.toBinaryString(numA));
// => (1이 28개) 1011
System.out.printf("%s\n", Integer.toBinaryString(result));
// => (1이 28개) 1101 (부호연산 그대로)
result = numA >>> 1;
System.out.printf("%s\n", Integer.toBinaryString(result));
// => (0하나) (1이 27개)1101 (부호연산 0으로)
```

# 조건문 
## if, case

## for, while

# 다차원 배열

# 클래스와 객체 1
- 객체를 정의하는 설계도. 
## 객체(Object)
- 실체
## 인스턴스
- 클래스와 객체의 관계
- 클래스로부터 객체를 선언. 
- 어떤 객체는 어떤 클래스의 인스턴스. 
## this, this()
- this => 객체 자신을 의미
- this() => 생성자


# 클래스와 객체 2
## 오버로딩
- 한 클래스 내에서 같은 이름의 메소드를 여러 개 정의
### 오버로딩의 조건
- 메소드의 이름이 같아야함
- 매개변수의 개수 또는 타입이 달라야함. 
- 리턴타입의 차이만으로 오버로딩되지 않음. 
## 접근제어자
- 클래스의 변수나 메소드의 접근에 제한을 두는 키워드
### 접근제어자 종류
- private : 해당 클래스에서만 접근 가능
- public : 어디서든 접근 가능
- default : 해당 패키지 내에서만 접근 가능
- protected: 해당 패키지 및 상속받은 클래스에서 접근 가능. 

## Static
- 변수나 메소드의 특성을 바꾸는 키워드
### Static 특징
- 메모리에 한 번만 할당됨
- 즉, Static 변수나 메소드는 공유되는 특성을 가짐
- 객체가 만들어지기 전에(프로그램 시작 시) 클래스 변수, 클래스 메소드가 메모리에 할당되어 있음. 
### Static 클래스 변수
- 해당 클래스의 각 객체들이 값을 공유
### Static 클래스 메소드
- 객체를 생성하지 않아도 호출 가능. 

``` java
class Car{
	static String name = "None";
	String type;
	Car(String name, String type){
		this.name = name;
		this.type = type;
	}
	public void printCarInfo(){
		System.out.println("name: " + name);
		System.out.println("type: " + type);
	}
	public static void getName(){
		System.out.println("Car name: " + name);
	}
}

public class Main{
	public static void main(String[] args){
		Car.getName(); //static은 객체 생성하지 않아도 이미 메모리에 올려져있음.
		Car myCar1 = new Car("a", "sedan");
		Car myCar2 = new Car("b", "suv");
		myCar1.printCarInfo(); //name:b type:sedan
		myCar2.printCarInfo(); //name:b type:suv ==> name은 static이라 공유됨!! 
	}
}
```

# 상속 
- 부모 클래스의 필드와 메소드가 상속 됨
- 생성자, 초기화 블록은 상속되지 않음
- 자식클래스는 하나의 부모 클래스만 상속 가능. 
- private, default 멤버를 자식 클래스에서 접근 불가.
- default의 경우 내부 패키지의 자식 클래스는 가능. 
## super, super()
- super : 부모 클래스와 자식 클래스의 멤버 이름이 같을 때 구분하는 키워드
- super() : 부모 클래스의 생성자 호출 

## 오버라이딩
- 부모클래스의 메소드를 자식클래스에서 재정의
- 메소드 선언부 부모 클래스의 메소드와 동일해야함
- **반환 타입에 한해서**,
- 부모 클래스의 반환타입으로 변환할 수 있는타입으로 변경 가능
- 부모 클래스의 메소드보다 접근제어자를 더 좁은 범위로 변경 불가
- 부모 클래스의 메소드보다 더 큰 범위의 예외 선언 불가 

# 다형성
- 하나의 객체가 여러가지 타입을 가질 수 있는 것 
- 부모클래스 타입의 참소변수로 자식 클래스 인스턴스 참조 
## 타입변환 (업캐스팅, 다운캐스팅)
```java
// 타입 변환 Student extends Person
Person pp1 = null;
Student ss1 = null;

Person pp2 = new Person();
Student ss2 = new Student();
Person pp3 = new Student(); // 업캐스팅(다형성)

pp1 = pp2;
pp1 = ss2;

ss1 = ss2;
// ss1 = pp2; 안됌
// ss1 = pp3; 이대론 안되지만
ss1 = (Student) pp3; // 다운캐스팅 이렇게 하면 가능 (원래 Student였는데 업캐스팅된 상태였음)

```



# 추상 클래스 & 추상 메소드 

```java
abstract class Person{
	abstract void printInfo();
}

class Student extends Person{
	public void printInfo(){
		System.out.println("Student.printInfo");
	}
}

public class Main{
	public static void main(String[] args){
		// 추상 클래스 사용
		// Person p1 = new Person();
		Student s1 = new Student();
		s1.printInfo();

		Person p2 = new Person(){ // 추상클래스 익명클래스를 통해 구현가능
			@Override
			void printInfo(){

			}
		};
	}
}
```

# 인터페이스
- 다중상속처럼 사용할 수 있는 기능
- 추상메소드와 상수만으로 이루어짐. 
```java
접근제어자 interface 인터페이스 이름{
	public static final 타입 상수입름 = 값;
	public abstract 반환타입 메소드이름(매개변수);
}
```

# 내부클래스
## 특징
- 내부 클래스에서 외부 클래스 멤버에 접근 가능
- 외부에서는 내부 클래스 접근 불가
## 종류
- 인스턴스 클래스
- 정적 클래스
- 지역 클래스
- 익명 클래스

### 익명 클래스
- 이름을 가지지 않는 클래스
- 선언과 동시에 객체 생성
- 일회용 클래스
```java
클래스이름 참조변수이름 = new 클래스이름(){
...
};
```

# 입출력
## 콘솔 입력
```java
System.in.read()
InputStreamReader reader = ...
BufferedReader br = ...
Scanner ...
```

- 예시 코드
```java
//System.in
int a = System.in.read() - '0'; //System.in.read()=>하나의 캐릭터 읽음
System.out.println("a = " + a);
System.in.read(new byte[System.in.available()]); // 입력스트림에 남아있는 개수 만큼 바이트만큼 읽어서 소진 (엔터키값 등)

//InputStreamReader
InputStreamReader reader = new InputStreamReader(System.in); //여러 글자 받음
char[] c = new char[3]; //여러 데이터 받기 때문에 그 만큼의 배열 길이 필요
reader.read(c); // 여기서 받음
System.out.println(c); //출력

//BufferedReader
//위의 2개가 합쳐진 개념. 
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String s1 = br.readLine(); // 여기서 받음.
System.out.println("s1 = " + s1);

//Scanner 
Scanner sc = new Scanner(System.in);
System.out.println(sc.next()); // 데이터 하나 받기 => 엔터키 소진 필요
sc.nextLine(); //엔터키 소진 

System.out.println(sc.nextInt()); //정수 값 받기 - 다른타입 에러 

System.out.println(sc.nextLine()); //가장 많이 사용 ! 

```

## 콘솔 출력 
```java
System.out.println(...);
System.out.print(...);
System.out.printf(...);
```
- printf 예시
```java
String s = "자바";
int number = 3;
System.out.println(s+ "는 언어 선호도 " + number +"위 입니다.");
System.out.printf("%는 언어 선호도 %d위 입니다.\n", s, number);

// 서식문자 
// %d 정수형
// %o 8진수
// %x 16진수 
// %f 실수 System.out.printf("%f\n", 5.2f);
// %c 문자
// %s 문자열 

// 여백
System.out.printf("%5d\n", 123); // "  123"
System.out.printf("%-5d\n", 123); // "123  "

// 소숫점 자리수 표현
System.out.printf("%.2f\n", 1.12645f); // 1.13 // 마지막자리 반올림한값 !!
```

# 파일 입출력 
## 파일 입력
- 입출력 방식 중 파일로부터 입력 받는 방법 
```java
FileInputStream ...
BufferedReader ...
```

```java
// 파일 입력
BufferedReader br = new BufferedReader(new FileReader("./memo.txt"));
//String line = br.readLine(); //한줄 씩 읽기 

while(true){
	String line = br.readLine();
	if(line == null){
		break;
	}
	System.out.println(line);
}
br.close();
```

## 파일 출력(파일 쓰기)
- 입출력 방식 중 파일로 출력(쓰기)하는 방법 
```java
FileOutputStream ...
FileWriter ...
PrintWriter ...
```

- 예시
``` java
// 1. 파일(로) 출력(쓰기)
// FileWriter
FileWriter fw = new FileWriter("./memo.txt");
String memo = "헤드 라인\n";
fw.wirte(memo);

memo = "1월 1일 날씨 맑음\n";
fw.write(memo);

fw.close();

//PritWiter 
PrintWriter pw = new PrintWriter("./memo.txt");
memo = "헤드 라인";
pw.println(memo); //ln자동추가
memo = "1월 1일 날씨 맑음";
pw.println(memo); //ln자동추가

pw.close();


// 파일 이어 쓰기
FileWriter fw2 = new FileWriter("./memo.txt", true); //append:  true
memo = "1월 2일 날씨 완전 맑음\n";
fw2.write(memo);
fw2.close();


PrintWriter pw2 = new PrintWriter(new FileWriter("./memo.txt", true));
memo = "1월 3일 날씨 또 맑음!";
pw2.println(memo);
pw2.close();
``` 


# 예외 처리
## 예외 (Exception)
- 정상적이지 않은 Case;
## throw, throws
- throw : 예외를 발생시킴
- throws : 예외를 전가시킴. 
``` java
...func(){
	throw new Exception(); // 발생 !!! // @예외 발생시킴(동사원형)
}
...func() throws Exception{ // 전가 !!! //func()가 @예외 발생시킨다.(3인칭단수)
	...
}
``` 

- 커스텀 예외
```java
//RuntimeException 상속 
class CustomException extends RuntimeException{}
```
- 예시
```java
class NotTenException extends RuntimeException{}

public class Main{
	public static boolean checkTenWithException(int ten){ // 예외 발생 예시 !!!
		try{
			if(ten != 10){
				throw new NotTenException(); //예외 이곳에서 처리 !!!
			}
		}catch(NotTenException e){
			System.out.println("e == " + e); //위의 사항 여기서 잡힙
			return false;
		}
		return true;
	}

	public static boolean checkTenWithThrows(int ten) throws NotTenException{ // 예외 전가 예시 !!!
		if(ten != 10){
			throw new NotTenException(); // 예외가 발생하면 일반 밖으로 보냄
		}
		return true;
	}

	public static void main(String[]args){
		// 예외 발생 예제인 경우 예외가 함수 안에서 처리됨 !!!
		Main.checkTenWithException(9); //false 리턴 //e == NotTenException 출력됨.

		//예외 전가 예제인 경우 예외가 밖으로 나와서 호출한 곳에서 처리 해주어야함 !!!

		try{
			checkTenWithThrows(9);	//false !!!
		}catch(NotTenException e){
			System.out.println("e == " + e); //e == NotTenException 출력됨.
		}
		
	}
}
```

# 컬렉션 프레임워크
- 여러 데이터를 편리하게 관리할 수 있게 만들어 놓은 것.
- 자료구조 및 알고리즘을 구조화
## 대표 인터페이스
- List 인터페이스, Set 인터페이스, Map 인터페이스.  

## List 인터페이스
- 순서가 있는 데이터의 집합
- 데이터 중복 허용
- 대표 구현 클래스 : ArrayList, LinkedList, Vector 

## Set 인터페이스
- 순서가 없는 데이터의 집합
- 데이터의 중복 허용하지 않음
- 대표 구현 클래스 : HashSet, TreeSet 

## Map 인터페이스
- 키와 값의 쌍으로 이루어진 데이터 집합
- 순서 유지하지 않음
- 대표 구현 클래스 : HashMap, TreeMap 

### ArrayList
```java
list.size()
list.contains(value) /// 값의 유무 
list.indexOf(value) // 값의 인덱스
```

### LinkedList
``` java
list.addFirst(value)
list.addLas(value)
list.removeFirst()
list.removeLast()
```

### HashSet
```java
set.add(1);
set.add(2);
set.add(3);
System.out.println(set); // set = [1, 2, 3] //toString()오버라이드 ..?
```

### TreeSet
```java
set.add(10);
set.add(5);
set.add(15);
System.out.println(set); // set = [5, 10, 15] // 정렬되어 출력됨
set.first();
set.last();
set.lower(10); //5
set.higher(10); //15
```

### HashMap
```java
System.out.println(map); // map {1="kiwi", 2="apple", 3="mango"}
```

### TreeMap
```java
map.put(10, "kiwi");
map.put(5, "apple");
map.put(15, "mango");
System.out.println(map); // map = {5=apple, 10=kiwi, 15=mongo} // 정렬되어 출력됨 
System.out.println(map.firstEntry()); // 5=appler
System.out.println(map.firstKey()); // 5
System.out.println(map.lastEntry()); //15=mango
System.out.println(map.lastKey()); // 15
System.out.println(map.lowerEntry(10)); //5=apple
System.out.println(map.higherKey(10)) // 15=mango
```

### 컬렉션 프레임워크 예제 - 로또 번호 만들기
```java
public static void main(String[] args){
	HashSet set = new HashSet();
	for(int i = 0; set.size() < 6; i++){
		int num = (num)(Math.random() * 45) + 1; //Math.random() 
		set.add(num); // 중복되면 사이즈 증가하지 않으므로 분기문없이 for문의 조건문으로 충분함.
	}
	LinkedList list = new LinkedList(set); // set을 그냥 LinkdList에 넣어서 생성했음 !!! 
	Collections.sort(list);

}
```

# 람다식
- 메소드 대신 하나의 식으로 표현하는 것
- 익명 함수
```
public int sum(int x, int y){ // 일반 함수
	return x + y;
}
(int x, int y) -> {return x + y;}
```

## 장점
- 코드 간결
- 코드 가독성 높아짐
- 생산성 높아짐
## 단점
- 재사용 불가능(익명)
- 디버깅 어령무
- 재귀함수로는 맞지 않음 (이름이 없기 때문)

## 람다식 예시
```java
interface ComputeTool{
	public abstarct int compute(int x, int y);

	//public abstarct int compute2(int x, int y); // 추상메소드 2개일 경우에 람다 사용 불가 (기본 익명 클래스는 그냥 오버라이딩하면 가능)
}
public class Main{
	public static void main(String[] args){
		ComputeTool cTool1 = new ComputTool(){ // 기본 익명 클래스
			@Override
			public int compute(int x, int y){
				return x + y;
			}
		};
		System.out.println(cTool.compute(1, 2)); //기본 사용

		// 람다식 !!!
		CoumputTool cTool2 = (x, y) -> { x + y}; // 위의 기본 익명 클래스와 같은 기능 
		System.out.println(cTool2.compute(1, 2)); // 람다 사용. 람다에서 메소드명 지정 안해줘도 인터페이스의 메소드 명을 사용할 수 있음. 
	}
}
```

# 스트림 
- 배열, 컬렉션 등의 데이터를 하나씩 참조하여 처리 가능한 기능
- for문의 사용을 중려 코드를 간결하게 함.
- 크게 3가지로 구성
- Stream 생성
- 중개 연산
- 최종 연산
- 데이터소스 객체.Stream생성().중개연산().최종연산();
## 스트림 생성
- 배열 스트림
```java
String[] arr = new String[]{"a", "b", "c"}
Stream stream = Array.Stream(arr);
```
- 컬렉션 스트림 
```java
ArrayList list = new ArrayList(Arrays.asList(1,2,3));
Stream stream = list.stream();
```
## 스트림 중개연상
- Filtering
- filter 내부 조건에 참인 요소들을 추출 
```java
IntStream intStream = IntStream.range(1, 10).filter(n->n%2==0);
```
- Mapping
- map 안의 연산을 요소별로 수행 
```java
IntStream intStream = IntStream.range(1,10).map(n -> n+1);
```

## 스트림 최종연산
- Sum, Average
```java
IntStream.range(1, 5).sum()
IntStream.range(1, 5).average().getAsDouble()
```
- min, max
```java
IntStream.range(1, 5).min().getAsInt();
IntStream.range(1, 5).max().getAsInt();
```

## 예제
- 스트림 생성 예시
```java
// 배열 스트림
Stream stream1 = Arrays.stream(arr);
stream1.forEach(System.out::println);

// 컬렉션 스트림
Stream stream2 = list1.stream();
        //stream2.forEach(System.out::println); -> 스트림 최종 연산 이후에 더 작업할 수 없음 !
stream2.forEach(num -> System.out.println("num = " + num));

// 스트림 builder
Stream StreamBuilder = Stream.builder().add(1).add(2).add(3).build();
streamBuilder.forEach(System.out::println);

// 스트림 generate
Stream streamGenerator = Stream.generate(()->"abc").limit(3); // 3번반복
streaGenerator.forEach(System.out::println);

// 스트림 iterate
Stream streamIterate = Stream.iterate(10, n -> n * 2).limit(3);
streamIterate.forEach(System.out::println);

// 기본타입 스트림
IntStream intStream = IntStream.ranget(1, 5);
intStream.forEach(System.out::println);
```
- 스트림 중개 연산 예시
```java
// Filtering(필터링)
IntStream intSteam2 = IntStream.range(1, 10).filter(n -> n % 2 == 0); //참인경우찾기
intStream2.forEach(System.out::println);

// Mapping(매핑)
IntSrteam intStream3 = IntStream.range(1, 10).map(n -> n+1); // 연산위주
intStream3.forEach(n -> System.out.print(n + " "));
System.out.println();

// Sorting
IntSream intStream4 = IntStream.builder().add(5).add(1).add(3).add(4).add(2).build();
IntSream intStreamSort = intStream4.sorted(); // 정렬
intStreamSort.forEach(System.out::println);
```

- 스트림 최종 연산 예시
```java
// Sum, Average
int sum = IntSream.range(1, 5).sum();
double average = IntStream.range(1, 5).average().getAsDouble();

// Min, Max
int min = IntStream.ranget(1, 5).min().getAsInt();
int max = IntStream.ranget(1, 5).max().getAsInt();

// reduce
Stream<Integer> stream3 = new ArrayList<Integer>(Arrays.asList(1,2,3,4,5));
stream3.reduce((x,y)->x+y).get(); // 연쇄적인 연산 => 1+2. 3+3. 6+4. 10+5.

// forEach
IntSream.range(1, 10).filter(n -> n ==5 ).forEach(System.out::println);
```
- 예제
```java
// 예제: 1~10 숫자 중 짝수 들의 합
int sum2 = IntStream.range(1, 11).filter(x -> x % 2 == 0).sum();
```



# 기초 수학

- 집합
- 경우의 수
- 순열 / 조합
- 점화식과 재귀함수
- 지수와 로그
- 알고리즘 복잡도 



# 집합
- 컬렉션 프레임워크 이용한 구현
- 직접 구현

## 집합의 개념
- 집합(Set)
- 특정 조건에 맞는 원소들의 모임
### 집합 표현 방법
- 원소 나열법 => A={1,2,3}, B={2,4,6}
- 조건 제시법 => A={A|A는 정수, 1<=A<=3}, B={2B|B는 정수, 1<=B<=3}
- 벤다이어 그램
#### 교집합
- 두 집합이 공통으로 포함하는 원소로 이루어진 집합
#### 합집합
- 어느 하나에라도 속하는 원소들을 모두 모은 집합
#### 차집합
- A(orB)에만 속하는 원소들의 집합
#### 여집합
- 전체집합(U) 중 A의 원소가 아닌 것들의 집합
## 집합 사용 예시 코드
```java
//1. 자바에서 집합사용 - HashSet
//2. 집합 연산
//2-1. 교집합
HashSet a = new HashSet(Arrays.asList(1,2,3,4,5));
HashSet b = new HashSet(Arrays.asList(2,4,6,8,10));
a.retainAll(b);// a교집합 b //[2, 4]
//2-2. 합집합
a.addAll(b); //a합집합 b[1,2,3,4,5,6,8,10]
//2-3 차집합
a.removeAll(b); //a차집합b[1,3,5]
```

# 경우의 수
- 합의 법칙, 곱의 법칙을 구분하기
- 경우의 수를 자바 프로그래밍으로 구현하기 
## 경우의 수 개념
- 어떤 사건에서 일어날 수 있는 경우의 가짓수
```
예시1) 동전을 던지는 사건 : 경우의 수 2
예시2) 주사위를 던지는 사건 : 경우의 수 6
- 사건 A가 일어날 경우의 수 : n(A)
```

## 합의 법칙 곱의 법칙
- 주사위 예시 경우의 수
- 최대공약수, 최소공배수
- 최소공배수공식) lcm = numA * numB /gcd;

### 합의 법칙 개념
- 사건 A 또는 사건 B가 일어날 경우
- 사건 A와 사건 B의 합의 법칙 : n(A ∪ B)
- n(A ∪ B) = n(A) + n(B) - n(A∩B)
```
예시) 두 개의 주사위를 던졌을 때 합이 3 또는 4의 배수일 경우의 수
```

### 곱의 법칙 개념
- 사건 A와 사건 B가 동시에 일어날 경우의 수
- 사건 A와 사건 B의 곱의 법칙: n(A x B)
- n(A x B) = n(A) x n(B)
```
예시) 두 개의 주사위 a, b를 던졌을 때 a는 3의 배수, b는 4의 배수인 경우의 수 
```


# 순열 / 조합
- 팩토리얼 (반복문, Stream)
- m개 숫자를 이용 n자리 자연수

## 순열
- 1. 팩토리얼
- 2. 순열
- 3. 중복 순열
- 4. 원 순열

### 팩토리얼
- 1에서 n까지 모든 자연수의 곱(n!)

### 순열(Permutation)
- 순서를 정해서 나열
- 서로 다른 n개 중에 r개를 선택하는 경우의 수 (순서 O, 중복 X)
- 예시) 5명을 3줄로 세우는 방법
- 예시) 서로 다른 4명 중 반장, 부반장 뽑는 방법. 
- n! / (n-r)! ==> n부터 n-r+1까지의 곱.!!!

### 중복 순열
- 서로 다른 n개 중에 r개를 선택하는 경우의 수 (순서O, 중복 O)
- 예시) 서로 다른 4개의 수 중 2개를 뽑는 방법(중복 허용)
- 예시) 후보 2명, 유권자 3명일 때 기명 투표 방법. 
- n^r

### 원순열
- 원 모양의 테이블에 n개의 원소를 나열하는 경우의 수
- 예시) 원모양의 테이블에 3명을 앉히는 경우
- n!/n = (n-1)!


## 조합
- 1. 조합
- 2. 중복 조합 
- 조합 개념의 이해와 경우의 수 계산
- 프로그래밍으로 조합의 각 case 출력 

### 조합(의 개념)
- 서로 다른 n개 중에서 r개를 선택하는 경우의 수 (순서X, 중복X)
- 예시) 서로 다른 4명 중 주번 2명을 뽑는 방법 (순열은 반장,부반장, <-> 조합은 주번)
- nCr = n! / (n-r)!r! = nPr / r! (0 < r <= n)

### 중복 조합
- 서로 다른 n개 중에서 r개를 선택하는 경우의 수 (순서X, 중복O)
- 예시) 후보 2명, 유권자 3명일 때 무기명 투표 방법
- nHr = n+r-1 C r

# 점화식과 재귀함수 
- 점화식과 재귀함수 개념 이해
- 점화식 유형을 파악하고 재귀함수로 구현 가능
- 여러가지 점화식을 재귀함수로 구현
- 최대공약수를 재귀함수로 구현

## 점화식(Recurrence)
- 어떤 수열의 일반항을 그 이전의 항들을 이용하여 정의한 식
- 예시) 피보나치 수열. 

## 재귀함수
- 어떤 함수가 자신을 다시 호출하여 작업을 수행하는 방식
```
반환타입 함수이름 (매개변수){
    종료조건
    ...
    함수이름(...)
}
```

# 지수와 로그
- 지수와 로그를 Math 클래스 사용한 구현
- 직접 구현
- 1. 제곱, 제곱근, 지수
- 2. 로그
## 제곱, 제곱근, 지수 개념
- 제곱 : 같은 수를 두 번 곱함
- 거듭 제곱 : 같은 수를 거듭하여(2번 이상) 곱함
- 제곱근 (=root)
- a를 제곱하여 b가 될 때 a를 b의 제곱근이라고 함
```
2^3 = 2 x 2 x 2
4^1/2 = 2^2x1/2 = 2
a^x -> a: 밑, x : 지수
```
- 자바 Math 클래스 활용
```java
// 2^3
Math.pow(2, 3); // 8
Math.pow(2, -3); // 1/2^3 == 1/8
Math.pow(2, 30); // 1.073741824E9 //10의 9승
//루트 16
Math.sqrt(16);	//4
Math.pow(16, 1.0/2); //4

// cf)절대값 구하기
Math.abs(-5) == Math.abs(5)
```

## 로그
- log a b
- a가 b가 되기 위해 제곱해야하는 수
```
log 2 4 = 2
log 10 1000 = 3
log e 2.718281828459... = 1  => (자연상수)
``` 
- 자바 Math 클래스 활용
```java
Math(E); // 자연상수 == 2.718281828459045
Math.log(2.718281828459045); // 1.0
Math.log10(1000); // 3
//log 2 4 계산하기(밑이 다른 로그)
Math.log(4) / Math.log(2) // 2.0  


```

# 알고리즘 복잡도
- 시간복잡도, 공간복잡도 개념 이해
- 빅오 표기법 이해와 코드에 대한 복잡도 산출 가능 
- 시간 복잡도 예시 코드
- 공간 복잡도 예시 코드 

## 복잡도
- 알고리즘 성능을 나타내는 척도
- 시간 복잡도 : 알고리즘의 필요 연산 횟수
- 공간 복잡도 : 알고리즘의 필요 메모리
- 시간 복잡도와 공간 복잡도는 Trade-off 관계 

## 시간 복잡도
- 어떤 분제를 해결하기 위한 알고리즘의 필요 연산 횟수
- 빅오 표기법을 통해 나타냄
- O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(2^n) 
- 상수시간<로그시간 < 선형시간 < 로그선형시간< 이차시간 < 지수시간 

## 공간 복잡도
- 어떤 문제를 해결하기 위한 알고리즘의 필요 메모리 사용량
- 빅오 표기법을 통해 나타냄
- 일반적으로 메모리 사용량 기준은 MB 단위
```java
int[] a = new int[1000]; //4KB
int[][] a = new int[1000][1000]; //4MB
```









